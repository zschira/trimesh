

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trimesh package &mdash; trimesh 2.34.8 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="trimesh.interfaces package" href="trimesh.interfaces.html" />
    <link rel="prev" title="Module Reference" href="modules.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> trimesh
          

          
          </a>

          
            
            
              <div class="version">
                2.34.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Advanced Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Module Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">trimesh package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.io.html">trimesh.io package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.scene.html">trimesh.scene package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.base">trimesh.base module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#github-com-mikedh-trimesh">github.com/mikedh/trimesh</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.boolean">trimesh.boolean module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.bounds">trimesh.bounds module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.caching">trimesh.caching module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#caching-py">caching.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.collision">trimesh.collision module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.comparison">trimesh.comparison module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comparison-py">comparison.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.constants">trimesh.constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.convex">trimesh.convex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.creation">trimesh.creation module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creation-py">creation.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.curvature">trimesh.curvature module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#curvature-py">curvature.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.decomposition">trimesh.decomposition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.geometry">trimesh.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.graph">trimesh.graph module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-py">graph.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.grouping">trimesh.grouping module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grouping-py">grouping.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.inertia">trimesh.inertia module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inertia-py">inertia.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.integrate">trimesh.integrate module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#integrate-py">integrate.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.intersections">trimesh.intersections module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intersections-py">intersections.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.nsphere">trimesh.nsphere module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nsphere-py">nsphere.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.permutate">trimesh.permutate module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#permutate-py">permutate.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.points">trimesh.points module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#points-py">points.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.poses">trimesh.poses module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#poses-py">poses.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.primitives">trimesh.primitives module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#primitives-py">primitives.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.proximity">trimesh.proximity module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#proximity-py">proximity.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.registration">trimesh.registration module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#registration-py">registration.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.remesh">trimesh.remesh module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#remesh-py">remesh.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.rendering">trimesh.rendering module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rendering-py">rendering.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.repair">trimesh.repair module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#repair-py">repair.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.sample">trimesh.sample module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sample-py">sample.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.transformations">trimesh.transformations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requirements">Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notes">Notes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.triangles">trimesh.triangles module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#triangles-py">triangles.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.units">trimesh.units module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#units-py">units.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.util">trimesh.util module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#util-py">util.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.version">trimesh.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.visual">trimesh.visual module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#visual-py">visual.py</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rules">Rules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.voxel">trimesh.voxel module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#voxel-py">voxel.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#https-github-com-mikedh-trimesh">https://github.com/mikedh/trimesh</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">trimesh</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">Module Reference</a> &raquo;</li>
        
      <li>trimesh package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/trimesh.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trimesh-package">
<h1>trimesh package<a class="headerlink" href="#trimesh-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.blender">trimesh.interfaces.blender module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.generic">trimesh.interfaces.generic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.scad">trimesh.interfaces.scad module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.vhacd">trimesh.interfaces.vhacd module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.io.html">trimesh.io package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.assimp">trimesh.io.assimp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.export">trimesh.io.export module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.gltf">trimesh.io.gltf module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.io.html#gltf-py">gltf.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.load">trimesh.io.load module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.misc">trimesh.io.misc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.openctm">trimesh.io.openctm module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.ply">trimesh.io.ply module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.stl">trimesh.io.stl module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.threemf">trimesh.io.threemf module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.urdf">trimesh.io.urdf module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.wavefront">trimesh.io.wavefront module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io.xml_based">trimesh.io.xml_based module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.io.html#module-trimesh.io">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.io.html">trimesh.path.io package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#module-trimesh.path.io.dxf">trimesh.path.io.dxf module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#module-trimesh.path.io.export">trimesh.path.io.export module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#module-trimesh.path.io.load">trimesh.path.io.load module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#module-trimesh.path.io.misc">trimesh.path.io.misc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#module-trimesh.path.io.svg_io">trimesh.path.io.svg_io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.io.html#module-trimesh.path.io">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.arc">trimesh.path.arc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.creation">trimesh.path.creation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.curve">trimesh.path.curve module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.entities">trimesh.path.entities module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#entities-py">entities.py</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.intersections">trimesh.path.intersections module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.packing">trimesh.path.packing module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.path">trimesh.path.path module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.polygons">trimesh.path.polygons module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.raster">trimesh.path.raster module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#raster-py">raster.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.simplify">trimesh.path.simplify module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.traversal">trimesh.path.traversal module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.util">trimesh.path.util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_pyembree">trimesh.ray.ray_pyembree module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_triangle">trimesh.ray.ray_triangle module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_util">trimesh.ray.ray_util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.resources.html#module-trimesh.resources">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.scene.html">trimesh.scene package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.scene">trimesh.scene.scene module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.transforms">trimesh.scene.transforms module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.viewer">trimesh.scene.viewer module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.viewerJS">trimesh.scene.viewerJS module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.scene.html#viewerjs-py">viewerJS.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh.base">
<span id="trimesh-base-module"></span><h2>trimesh.base module<a class="headerlink" href="#module-trimesh.base" title="Permalink to this headline">¶</a></h2>
<div class="section" id="github-com-mikedh-trimesh">
<h3>github.com/mikedh/trimesh<a class="headerlink" href="#github-com-mikedh-trimesh" title="Permalink to this headline">¶</a></h3>
<p>Library for importing, exporting and doing simple operations on triangular meshes.</p>
<dl class="class">
<dt id="trimesh.base.Trimesh">
<em class="property">class </em><code class="descclassname">trimesh.base.</code><code class="descname">Trimesh</code><span class="sig-paren">(</span><em>vertices=None</em>, <em>faces=None</em>, <em>face_normals=None</em>, <em>vertex_normals=None</em>, <em>face_colors=None</em>, <em>vertex_colors=None</em>, <em>metadata=None</em>, <em>process=True</em>, <em>validate=False</em>, <em>use_embree=True</em>, <em>initial_cache={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.base.Trimesh.area" title="trimesh.base.Trimesh.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a></dt>
<dd><p class="first last">Summed area of all triangles in the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.area_faces" title="trimesh.base.Trimesh.area_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></a></dt>
<dd><p class="first last">The area of each face in the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.body_count" title="trimesh.base.Trimesh.body_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></a></dt>
<dd><p class="first last">How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounding_box" title="trimesh.base.Trimesh.bounding_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></a></dt>
<dd><p class="first last">An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounding_box_oriented" title="trimesh.base.Trimesh.bounding_box_oriented"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></a></dt>
<dd><p class="first last">An oriented bounding box for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounding_cylinder" title="trimesh.base.Trimesh.bounding_cylinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></a></dt>
<dd><p class="first last">A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounding_primitive" title="trimesh.base.Trimesh.bounding_primitive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></a></dt>
<dd><p class="first last">The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounding_sphere" title="trimesh.base.Trimesh.bounding_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></a></dt>
<dd><p class="first last">A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounds" title="trimesh.base.Trimesh.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt>
<dd><p class="first last">The axis aligned bounds of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.center_mass" title="trimesh.base.Trimesh.center_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></a></dt>
<dd><p class="first last">The point in space which is the center of mass/volume.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.centroid" title="trimesh.base.Trimesh.centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></a></dt>
<dd><p class="first last">The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.convex_hull" title="trimesh.base.Trimesh.convex_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></a></dt>
<dd><p class="first last">Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.density" title="trimesh.base.Trimesh.density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></a></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges" title="trimesh.base.Trimesh.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></dt>
<dd><p class="first last">Edges of the mesh (derived from faces).</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_face" title="trimesh.base.Trimesh.edges_face"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></a></dt>
<dd><p class="first last">Which face does each edge belong to.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_sorted" title="trimesh.base.Trimesh.edges_sorted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></a></dt>
<dd><p class="first last">Edges sorted along axis 1</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_sparse" title="trimesh.base.Trimesh.edges_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></a></dt>
<dd><p class="first last">Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_unique" title="trimesh.base.Trimesh.edges_unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></a></dt>
<dd><p class="first last">The unique edges of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_unique_length" title="trimesh.base.Trimesh.edges_unique_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></a></dt>
<dd><p class="first last">How long is each unique edge.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.euler_number" title="trimesh.base.Trimesh.euler_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></a></dt>
<dd><p class="first last">Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.extents" title="trimesh.base.Trimesh.extents"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></a></dt>
<dd><p class="first last">The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency" title="trimesh.base.Trimesh.face_adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></a></dt>
<dd><p class="first last">Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_angles" title="trimesh.base.Trimesh.face_adjacency_angles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></a></dt>
<dd><p class="first last">Return the angle between adjacent faces</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_convex" title="trimesh.base.Trimesh.face_adjacency_convex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></a></dt>
<dd><p class="first last">Return faces which are adjacent and locally convex.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_edges" title="trimesh.base.Trimesh.face_adjacency_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></a></dt>
<dd><p class="first last">Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_projections" title="trimesh.base.Trimesh.face_adjacency_projections"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></a></dt>
<dd><p class="first last">The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_radius" title="trimesh.base.Trimesh.face_adjacency_radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></a></dt>
<dd><p class="first last">The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_span" title="trimesh.base.Trimesh.face_adjacency_span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></a></dt>
<dd><p class="first last">The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_tree" title="trimesh.base.Trimesh.face_adjacency_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></a></dt>
<dd><p class="first last">An R-tree of face adjacencies.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_unshared" title="trimesh.base.Trimesh.face_adjacency_unshared"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></a></dt>
<dd><p class="first last">Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_angles" title="trimesh.base.Trimesh.face_angles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></a></dt>
<dd><p class="first last">Returns the angle at each vertex of a face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_angles_sparse" title="trimesh.base.Trimesh.face_angles_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></a></dt>
<dd><p class="first last">A sparse matrix representation of the face angles.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_normals" title="trimesh.base.Trimesh.face_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></a></dt>
<dd><p class="first last">Return the unit normal vector for each face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.faces" title="trimesh.base.Trimesh.faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></a></dt>
<dd><p class="first last">The faces of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.faces_sparse" title="trimesh.base.Trimesh.faces_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></a></dt>
<dd><p class="first last">A sparse matrix representation of the faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.faces_unique_edges" title="trimesh.base.Trimesh.faces_unique_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></a></dt>
<dd><p class="first last">For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets" title="trimesh.base.Trimesh.facets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></a></dt>
<dd><p class="first last">Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_area" title="trimesh.base.Trimesh.facets_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></a></dt>
<dd><p class="first last">Return an array containing the area of each facet.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_boundary" title="trimesh.base.Trimesh.facets_boundary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></a></dt>
<dd><p class="first last">Return the edges which represent the boundary of each facet</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_normal" title="trimesh.base.Trimesh.facets_normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></a></dt>
<dd><p class="first last">Return the normal of each facet</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_on_hull" title="trimesh.base.Trimesh.facets_on_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></a></dt>
<dd><p class="first last">Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_origin" title="trimesh.base.Trimesh.facets_origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></a></dt>
<dd><p class="first last">Return a point on the facet plane.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.identifier" title="trimesh.base.Trimesh.identifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></a></dt>
<dd><p class="first last">Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.identifier_md5" title="trimesh.base.Trimesh.identifier_md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></a></dt>
<dd><p class="first last">An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_convex" title="trimesh.base.Trimesh.is_convex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></a></dt>
<dd><p class="first last">Check if a mesh is convex or not.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_empty" title="trimesh.base.Trimesh.is_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></a></dt>
<dd><p class="first last">Does the current mesh have data defined.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_volume" title="trimesh.base.Trimesh.is_volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></a></dt>
<dd><p class="first last">Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_watertight" title="trimesh.base.Trimesh.is_watertight"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></a></dt>
<dd><p class="first last">Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_winding_consistent" title="trimesh.base.Trimesh.is_winding_consistent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></a></dt>
<dd><p class="first last">Does the mesh have consistent winding or not.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.kdtree" title="trimesh.base.Trimesh.kdtree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></a></dt>
<dd><p class="first last">Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.mass" title="trimesh.base.Trimesh.mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></a></dt>
<dd><p class="first last">Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.mass_properties" title="trimesh.base.Trimesh.mass_properties"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></a></dt>
<dd><p class="first last">Returns the mass properties of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.moment_inertia" title="trimesh.base.Trimesh.moment_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></a></dt>
<dd><p class="first last">Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.principal_inertia_components" title="trimesh.base.Trimesh.principal_inertia_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></a></dt>
<dd><p class="first last">Return the principal components of inertia</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.principal_inertia_transform" title="trimesh.base.Trimesh.principal_inertia_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></a></dt>
<dd><p class="first last">A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.principal_inertia_vectors" title="trimesh.base.Trimesh.principal_inertia_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></a></dt>
<dd><p class="first last">Return the principal axis of inertia.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.scale" title="trimesh.base.Trimesh.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a></dt>
<dd><p class="first last">A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.symmetry" title="trimesh.base.Trimesh.symmetry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></a></dt>
<dd><p class="first last">Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.symmetry_axis" title="trimesh.base.Trimesh.symmetry_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></a></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.symmetry_section" title="trimesh.base.Trimesh.symmetry_section"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></a></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles" title="trimesh.base.Trimesh.triangles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></a></dt>
<dd><p class="first last">Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles_center" title="trimesh.base.Trimesh.triangles_center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></a></dt>
<dd><p class="first last">The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles_cross" title="trimesh.base.Trimesh.triangles_cross"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></a></dt>
<dd><p class="first last">The cross product of two edges of each triangle.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles_tree" title="trimesh.base.Trimesh.triangles_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></a></dt>
<dd><p class="first last">An R-tree containing each face of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.units" title="trimesh.base.Trimesh.units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></a></dt>
<dd><p class="first last">Definition of units for the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_adjacency_graph" title="trimesh.base.Trimesh.vertex_adjacency_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></a></dt>
<dd><p class="first last">Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_defects" title="trimesh.base.Trimesh.vertex_defects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></a></dt>
<dd><p class="first last">Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_neighbors" title="trimesh.base.Trimesh.vertex_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></a></dt>
<dd><p class="first last">The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_normals" title="trimesh.base.Trimesh.vertex_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></a></dt>
<dd><p class="first last">The vertex normals of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertices" title="trimesh.base.Trimesh.vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></a></dt>
<dd><p class="first last">The vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.volume" title="trimesh.base.Trimesh.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt>
<dd><p class="first last">Volume of the current mesh calculated using a surface integral.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.apply_obb" title="trimesh.base.Trimesh.apply_obb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code></a>()</td>
<td>Apply the oriented bounding box transform to the current mesh.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.apply_scale" title="trimesh.base.Trimesh.apply_scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code></a>(scaling)</td>
<td>Scale the mesh equally on all axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.apply_transform" title="trimesh.base.Trimesh.apply_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code></a>(matrix)</td>
<td>Transform mesh by a homogenous transformation matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.apply_translation" title="trimesh.base.Trimesh.apply_translation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code></a>(translation)</td>
<td>Translate the current mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.compute_stable_poses" title="trimesh.base.Trimesh.compute_stable_poses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code></a>([center_mass,&nbsp;sigma,&nbsp;…])</td>
<td>Computes stable orientations of a mesh and their quasi-static probabilites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.contains" title="trimesh.base.Trimesh.contains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code></a>(points)</td>
<td>Given a set of points, determine whether or not they are inside the mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.convert_units" title="trimesh.base.Trimesh.convert_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code></a>(desired[,&nbsp;guess])</td>
<td>Convert the units of the mesh into a specified unit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.convex_decomposition" title="trimesh.base.Trimesh.convex_decomposition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code></a>([engine,&nbsp;maxhulls])</td>
<td>Compute an approximate convex decomposition of a mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.copy" title="trimesh.base.Trimesh.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Safely get a copy of the current mesh.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.crc" title="trimesh.base.Trimesh.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</td>
<td>A zlib.adler32 checksum for the current mesh data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.difference" title="trimesh.base.Trimesh.difference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code></a>(other[,&nbsp;engine])</td>
<td>Boolean difference between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.eval_cached" title="trimesh.base.Trimesh.eval_cached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code></a>(statement,&nbsp;*args)</td>
<td>Evaluate a statement and cache the result before returning.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.export" title="trimesh.base.Trimesh.export"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code></a>([file_obj,&nbsp;file_type])</td>
<td>Export the current mesh to a file object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.fill_holes" title="trimesh.base.Trimesh.fill_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code></a>()</td>
<td>Fill single triangle and single quad holes in the current mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.fix_normals" title="trimesh.base.Trimesh.fix_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code></a>(**kwargs)</td>
<td>Find and fix problems with self.face_normals and self.faces winding direction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.intersection" title="trimesh.base.Trimesh.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code></a>(other[,&nbsp;engine])</td>
<td>Boolean intersection between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.invert" title="trimesh.base.Trimesh.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>()</td>
<td>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.md5" title="trimesh.base.Trimesh.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</td>
<td>An MD5 of the core geometry information for the mesh, faces and vertices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.merge_vertices" title="trimesh.base.Trimesh.merge_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code></a>([distance])</td>
<td>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.outline" title="trimesh.base.Trimesh.outline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code></a>([face_ids])</td>
<td>Given a set of face ids, find the outline of the faces, and return it as a Path3D.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.process" title="trimesh.base.Trimesh.process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code></a>()</td>
<td>Do the bare minimum processing to make a mesh useful.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.register" title="trimesh.base.Trimesh.register"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code></a>(other,&nbsp;**kwargs)</td>
<td>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.remove_degenerate_faces" title="trimesh.base.Trimesh.remove_degenerate_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code></a>([height])</td>
<td>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.remove_duplicate_faces" title="trimesh.base.Trimesh.remove_duplicate_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code></a>()</td>
<td>On the current mesh remove any faces which are duplicates.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.remove_infinite_values" title="trimesh.base.Trimesh.remove_infinite_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code></a>()</td>
<td>Ensure that every vertex and face consists of finite numbers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.remove_unreferenced_vertices" title="trimesh.base.Trimesh.remove_unreferenced_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code></a>()</td>
<td>Remove all vertices in the current mesh which are not referenced by a face.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.rezero" title="trimesh.base.Trimesh.rezero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code></a>()</td>
<td>Translate the mesh so that all vertex vertices are positive.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.sample" title="trimesh.base.Trimesh.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code></a>(count[,&nbsp;return_index])</td>
<td>Return random samples distributed normally across the surface of the mesh</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.scene" title="trimesh.base.Trimesh.scene"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code></a>(**kwargs)</td>
<td>Get a Scene object containing the current mesh.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.section" title="trimesh.base.Trimesh.section"><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code></a>(plane_normal,&nbsp;plane_origin)</td>
<td>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.section_multiplane" title="trimesh.base.Trimesh.section_multiplane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code></a>(plane_origin,&nbsp;…)</td>
<td>Return multiple parallel cross sections of the current mesh in 2D.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.show" title="trimesh.base.Trimesh.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>(**kwargs)</td>
<td>Render the mesh in an opengl window.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.smoothed" title="trimesh.base.Trimesh.smoothed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code></a>(**kwargs)</td>
<td>Return a version of the current mesh which will render nicely.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.split" title="trimesh.base.Trimesh.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(**kwargs)</td>
<td>Returns a list of Trimesh objects, based on face connectivity.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.subdivide" title="trimesh.base.Trimesh.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([face_index])</td>
<td>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.submesh" title="trimesh.base.Trimesh.submesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code></a>(faces_sequence,&nbsp;**kwargs)</td>
<td>Return a subset of the mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.to_dict" title="trimesh.base.Trimesh.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>()</td>
<td>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.union" title="trimesh.base.Trimesh.union"><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code></a>(other[,&nbsp;engine])</td>
<td>Boolean union between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.unmerge_vertices" title="trimesh.base.Trimesh.unmerge_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code></a>()</td>
<td>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.update_faces" title="trimesh.base.Trimesh.update_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code></a>(mask)</td>
<td>In many cases, we will want to remove specific faces.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.base.Trimesh.update_vertices" title="trimesh.base.Trimesh.update_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code></a>(mask[,&nbsp;inverse])</td>
<td>Update vertices with a mask.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.base.Trimesh.voxelized" title="trimesh.base.Trimesh.voxelized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code></a>(pitch,&nbsp;**kwargs)</td>
<td>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.base.Trimesh.apply_obb">
<code class="descname">apply_obb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_obb" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the oriented bounding box transform to the current mesh.</p>
<p>This will result in a mesh with an AABB centered at the
origin and the same dimensions as the OBB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4, 4) float</span></dt>
<dd><p class="first last">Transformation matrix that was applied
to mesh to move it into OBB frame</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.apply_scale">
<code class="descname">apply_scale</code><span class="sig-paren">(</span><em>scaling</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the mesh equally on all axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scale factor to apply to the mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mesh by a homogenous transformation matrix.</p>
<p>Does the bookkeeping to avoid recomputing things so this function
should be used rather than directly modifying self.vertices
if possible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4, 4) float</span></dt>
<dd><p class="first last">Homogenous transformation matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.apply_translation">
<code class="descname">apply_translation</code><span class="sig-paren">(</span><em>translation</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>translation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Translation in XYZ</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.area">
<code class="descname">area</code><a class="headerlink" href="#trimesh.base.Trimesh.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Summed area of all triangles in the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Surface area of mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.area_faces">
<code class="descname">area_faces</code><a class="headerlink" href="#trimesh.base.Trimesh.area_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The area of each face in the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area_faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">Area of each face</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.body_count">
<code class="descname">body_count</code><a class="headerlink" href="#trimesh.base.Trimesh.body_count" title="Permalink to this definition">¶</a></dt>
<dd><p>How many connected groups of vertices exist in this mesh.</p>
<p>Note that this number may differ from result in mesh.split,
which is calculated from FACE rather than vertex adjacency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of connected vertex groups</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounding_box">
<code class="descname">bounding_box</code><a class="headerlink" href="#trimesh.base.Trimesh.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>An axis aligned bounding box for the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aabb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.primitives.Box</span></dt>
<dd><p class="first last">Box object with transform and extents defined
representing the axis aligned bounding box of the mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounding_box_oriented">
<code class="descname">bounding_box_oriented</code><a class="headerlink" href="#trimesh.base.Trimesh.bounding_box_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>An oriented bounding box for the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.primitives.Box</span></dt>
<dd><p class="first last">Box object with transform and extents defined
representing the minimum volume oriented bounding box of the mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounding_cylinder">
<code class="descname">bounding_cylinder</code><a class="headerlink" href="#trimesh.base.Trimesh.bounding_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>A minimum volume bounding cylinder for the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mincyl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.primitives.Cylinder</span></dt>
<dd><p class="first last">Cylinder primitive containing current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounding_primitive">
<code class="descname">bounding_primitive</code><a class="headerlink" href="#trimesh.base.Trimesh.bounding_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum volume primitive (box, sphere, or cylinder) that
bounds the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bounding_primitive</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.primitives.Sphere</span></dt>
<dd><blockquote class="first">
<div><p>trimesh.primitives.Box
trimesh.primitives.Cylinder</p>
</div></blockquote>
<p class="last">Primitive which bounds the mesh with the smallest volume</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounding_sphere">
<code class="descname">bounding_sphere</code><a class="headerlink" href="#trimesh.base.Trimesh.bounding_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>A minimum volume bounding sphere for the current mesh.</p>
<p>Note that the Sphere primitive returned has an unpadded, exact
sphere_radius so while the distance of every vertex of the current
mesh from sphere_center will be less than sphere_radius, the faceted
sphere primitive may not contain every vertex</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>minball: trimesh.primitives.Sphere</strong></dt>
<dd><p class="first last">Sphere primitive containing current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.base.Trimesh.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2, 3) float</span></dt>
<dd><p class="first last">Bounding box with [min, max] coordinates</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.center_mass">
<code class="descname">center_mass</code><a class="headerlink" href="#trimesh.base.Trimesh.center_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the center of mass/volume.</p>
<p>If the current mesh is not watertight, this is meaningless garbage
unless it was explicitly set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>center_mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Volumetric center of mass of the mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.centroid">
<code class="descname">centroid</code><a class="headerlink" href="#trimesh.base.Trimesh.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the average of the triangle centroids
weighted by the area of each triangle.</p>
<p>This will be valid even for non- watertight meshes,
unlike self.center_mass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>centroid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">The average vertex weighted by face area</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.compute_stable_poses">
<code class="descname">compute_stable_poses</code><span class="sig-paren">(</span><em>center_mass=None</em>, <em>sigma=0.0</em>, <em>n_samples=1</em>, <em>threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian (mean at com, cov equal to identity times sigma) over n_samples.
For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaulates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogenous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.
The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>center_mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">The object center of mass (if None, this method
assumes uniform density and watertightness and
computes a center of mass explicitly)</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The covariance for the multivariate gaussian used
to sample center of mass locations</p>
</dd>
<dt><strong>n_samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of samples of the center of mass location</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The probability value at which to threshold
returned stable poses</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transforms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 4, 4) float</span></dt>
<dd><p class="first last">The homogenous matrices that transform the
object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p>
</dd>
<dt><strong>probs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">A probability ranging from 0.0 to 1.0 for each pose</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, determine whether or not they are inside the mesh.
This raises an error if called on a non- watertight mesh.</p>
<dl class="docutils">
<dt>points <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd>Points in cartesian space</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>contains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, ) bool</span></dt>
<dd><p class="first last">Whether or not each point is inside the mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convert_units">
<code class="descname">convert_units</code><span class="sig-paren">(</span><em>desired</em>, <em>guess=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the units of the mesh into a specified unit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>desired</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Units to convert to (eg ‘inches’)</p>
</dd>
<dt><strong>guess</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If self.units are not defined should we
guess the current units of the document and then convert?</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convex_decomposition">
<code class="descname">convex_decomposition</code><span class="sig-paren">(</span><em>engine=None</em>, <em>maxhulls=20</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<p>testVHACD Parameters which can be passed as kwargs:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>maxhulls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of convex hulls to return</p>
</dd>
<dt><strong>engine</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Which backend to use. Valid choice is ‘vhacd’.</p>
</dd>
<dt><strong>**kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">testVHACD keyword arguments</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>meshes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of trimesh.Trimesh</span></dt>
<dd><p class="first last">List of convex meshes that approximate the original</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.convex_hull">
<code class="descname">convex_hull</code><a class="headerlink" href="#trimesh.base.Trimesh.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of
the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>convex</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Mesh of convex hull of current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current mesh.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>copied</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Copy of current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.adler32 checksum for the current mesh data.</p>
<p>This is about 5x faster than an MD5, and the checksum is
checked every time something is requested from the cache so
it gets called a lot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>crc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Checksum of current mesh data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.density">
<code class="descname">density</code><a class="headerlink" href="#trimesh.base.Trimesh.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The density of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>other</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean difference between this mesh and n other meshes</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh, or list of trimesh.Trimesh objects</span></dt>
<dd>Meshes to difference</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>difference</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Difference between self and other Trimesh objects</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges">
<code class="descname">edges</code><a class="headerlink" href="#trimesh.base.Trimesh.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges of the mesh (derived from faces).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) int</span></dt>
<dd><p class="first last">List of vertex indices making up edges</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_face">
<code class="descname">edges_face</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_face" title="Permalink to this definition">¶</a></dt>
<dd><p>Which face does each edge belong to.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges_face</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) int</span></dt>
<dd><p class="first last">Index of self.faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_sorted">
<code class="descname">edges_sorted</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges sorted along axis 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges_sorted</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2)</span></dt>
<dd><p class="first last">Same as self.edges but sorted along axis 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_sparse">
<code class="descname">edges_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges in sparse bool COO graph format where connected
vertices are True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sparse: (len(self.vertices), len(self.vertices)) bool</strong></dt>
<dd><p class="first last">Sparse graph in COO format</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_unique">
<code class="descname">edges_unique</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique edges of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges_unique</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) int</span></dt>
<dd><p class="first last">Vertex indices for unique edges</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_unique_length">
<code class="descname">edges_unique_length</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique_length" title="Permalink to this definition">¶</a></dt>
<dd><p>How long is each unique edge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>length</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.edges_unique), ) float</span></dt>
<dd><p class="first last">Length of each unique edge</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.euler_number">
<code class="descname">euler_number</code><a class="headerlink" href="#trimesh.base.Trimesh.euler_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euler characteristic (a topological invariant) for the mesh
In order to guarantee correctness, this should be called after
remove_unreferenced_vertices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>euler_number</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Topological invariant</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.eval_cached">
<code class="descname">eval_cached</code><span class="sig-paren">(</span><em>statement</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.eval_cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a statement and cache the result before returning.</p>
<p>Statements are evaluated inside the Trimesh object, and</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>statement</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Statement of valid python code</p>
</dd>
<dt><strong>*args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Available inside statement as args[0], etc</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">result of running eval on statement with args</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>r = mesh.eval_cached(‘np.dot(self.vertices, args[0])’, [0,0,1])</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.export">
<code class="descname">export</code><span class="sig-paren">(</span><em>file_obj=None</em>, <em>file_type=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the current mesh to a file object.
If file_obj is a filename, file will be written there.</p>
<p>Supported formats are stl, off, ply, collada, json, dict, glb,
dict64, msgpack.</p>
<dl class="docutils">
<dt>file_obj: open writeable file object</dt>
<dd>str, file name where to save the mesh
None, if you would like this function to return the export blob</dd>
<dt>file_type: str</dt>
<dd>Which file type to export as.
If file name is passed this is not required</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.extents">
<code class="descname">extents</code><a class="headerlink" href="#trimesh.base.Trimesh.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The length, width, and height of the bounding box of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extents</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Array containing axis aligned [length, width, height]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency">
<code class="descname">face_adjacency</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adjacency</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,2) int</span></dt>
<dd><p class="first last">Pairs of faces which share an edge</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [1]: mesh = trimesh.load(‘models/featuretype.STL’)</p>
<p>In [2]: mesh.face_adjacency
Out[2]:
array([[   0,    1],</p>
<blockquote>
<div>[   2,    3],
[   0,    3],
…,
[1112,  949],
[3467, 3475],
[1113, 3475]])</div></blockquote>
<p>In [3]: mesh.faces[mesh.face_adjacency[0]]
Out[3]:
TrackedArray([[   1,    0,  408],</p>
<blockquote>
<div>[1239,    0,    1]], dtype=int64)</div></blockquote>
<p>In [4]: import networkx as nx</p>
<p>In [5]: graph = nx.from_edgelist(mesh.face_adjacency)</p>
<p>In [6]: groups = nx.connected_components(graph)</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_angles">
<code class="descname">face_adjacency_angles</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle between adjacent faces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adjacency_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">Angle between adjacent faces
Each value corresponds with self.face_adjacency</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_convex">
<code class="descname">face_adjacency_convex</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return faces which are adjacent and locally convex.</p>
<p>What this means is that given faces A and B, the one vertex
in B that is not shared with A, projected onto the plane of A
has a projection that is zero or negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>are_convex</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.face_adjacency),) bool</span></dt>
<dd><p class="first last">Face pairs that are locally convex</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_edges">
<code class="descname">face_adjacency_edges</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edges that are shared by the adjacent faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) int</span></dt>
<dd><p class="first last">Vertex indices which correspond to face_adjacency</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_projections">
<code class="descname">face_adjacency_projections</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection of the non- shared vertex of a triangle onto
its adjacent face</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>projections</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.face_adjacency),) float</span></dt>
<dd><p class="first last">Dot product of vertex
onto plane of adjacent triangle.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_radius">
<code class="descname">face_adjacency_radius</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.face_adjacency),) float</span></dt>
<dd><p class="first last">Approximate radius formed by triangle pair</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_span">
<code class="descname">face_adjacency_span</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_span" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate perpendicular projection of the non- shared
vertices in a pair of adjacent faces onto the shared edge of
the two faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>span</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.face_adjacency),) float</span></dt>
<dd><p class="first last">Approximate span between the non- shared vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_tree">
<code class="descname">face_adjacency_tree</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree of face adjacencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tree: rtree.index</strong></dt>
<dd><p class="first last">Where each edge in self.face_adjacency has a
rectangular cell</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_unshared">
<code class="descname">face_adjacency_unshared</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vid_unshared</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(mesh.face_adjacency), 2) int</span></dt>
<dd><p class="first last">Indexes of mesh.vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_angles">
<code class="descname">face_angles</code><a class="headerlink" href="#trimesh.base.Trimesh.face_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle at each vertex of a face.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Angle at each vertex of a face</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_angles_sparse">
<code class="descname">face_angles_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sparse: scipy.sparse.coo_matrix with:</strong></dt>
<dd><p class="first last">dtype: float
shape: (len(self.vertices), len(self.faces))</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_normals">
<code class="descname">face_normals</code><a class="headerlink" href="#trimesh.base.Trimesh.face_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unit normal vector for each face.</p>
<p>If a face is degenerate and a normal can’t be generated
a zero magnitude unit vector will be returned for that face.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>normals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.faces), 3) np.float64</span></dt>
<dd><p class="first last">Normal vectors of each face</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.faces">
<code class="descname">faces</code><a class="headerlink" href="#trimesh.base.Trimesh.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The faces of the mesh.</p>
<p>This is regarded as core information which cannot be regenerated from
cache, and as such is stored in self._data which tracks the array for
changes and clears cached values of the mesh if this is altered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) int</span></dt>
<dd><p class="first last">Representing triangles which reference self.vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.faces_sparse">
<code class="descname">faces_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.faces_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scipy.sparse.coo_matrix</span></dt>
<dd><p class="first last">Has properties:
dtype : bool
shape : (len(self.vertices), len(self.faces))</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.faces_unique_edges">
<code class="descname">faces_unique_edges</code><a class="headerlink" href="#trimesh.base.Trimesh.faces_unique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>For each face return which indexes in mesh.unique_edges constructs
that face.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>faces_unique_edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.faces), 3) int</span></dt>
<dd><p class="first last">Indexes of self.edges_unique that
construct self.faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [0]: mesh.faces[0:2]
Out[0]:
TrackedArray([[    1,  6946, 24224],</p>
<blockquote>
<div>[ 6946,  1727, 24225]])</div></blockquote>
<p>In [1]: mesh.edges_unique[mesh.faces_unique_edges[0:2]]
Out[1]:
array([[[    1,  6946],</p>
<blockquote>
<div><blockquote>
<div>[ 6946, 24224],
[    1, 24224]],</div></blockquote>
<dl class="docutils">
<dt>[[ 1727,  6946],</dt>
<dd>[ 1727, 24225],
[ 6946, 24225]]])</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets">
<code class="descname">facets</code><a class="headerlink" href="#trimesh.base.Trimesh.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of face indices for coplanar adjacent faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>facets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, ) sequence of (m,) int</span></dt>
<dd><p class="first last">Groups of indexes of self.faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_area">
<code class="descname">facets_area</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing the area of each facet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.facets),) float</span></dt>
<dd><p class="first last">Total area of each facet (group of faces)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_boundary">
<code class="descname">facets_boundary</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edges which represent the boundary of each facet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges_boundary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of (n, 2) int</span></dt>
<dd><p class="first last">Indices of self.vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_normal">
<code class="descname">facets_normal</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal of each facet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>normals: (len(self.facets), 3) float</strong></dt>
<dd><p class="first last">A unit normal vector for each facet</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_on_hull">
<code class="descname">facets_on_hull</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_on_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Find which facets of the mesh are on the convex hull.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>on_hull</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(mesh.facets),) bool</span></dt>
<dd><p class="first last">is A facet on the meshes convex hull or not</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_origin">
<code class="descname">facets_origin</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a point on the facet plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>origins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.facets), 3) float</span></dt>
<dd><p class="first last">A point on each facet plane</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.fill_holes">
<code class="descname">fill_holes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single triangle and single quad holes in the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>watertight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Is the mesh watertight after the function completes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.fix_normals">
<code class="descname">fix_normals</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and fix problems with self.face_normals and self.faces
winding direction.</p>
<p>For face normals ensure that vectors are consistently pointed
outwards, and that self.faces is wound in the correct direction
for all connected components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>multibody</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or bool</span></dt>
<dd><p class="first last">Fix normals across multiple bodies
if None automatically pick from body_count</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.identifier">
<code class="descname">identifier</code><a class="headerlink" href="#trimesh.base.Trimesh.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a float vector which is unique to the mesh
and is robust to rotation and translation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>identifier</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(6,) float</span></dt>
<dd><p class="first last">Identifying properties of the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.identifier_md5">
<code class="descname">identifier_md5</code><a class="headerlink" href="#trimesh.base.Trimesh.identifier_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the rotation invariant identifier vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hashed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">MD5 hash of the identifier vector</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean intersection between this mesh and n other meshes</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh, or list of trimesh.Trimesh objects</span></dt>
<dd>Meshes to calculate intersections with</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intersection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Mesh of the volume contained by all passed meshes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.invert">
<code class="descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the mesh in- place by reversing the winding of every
face and negating normals without dumping the cache.</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_convex">
<code class="descname">is_convex</code><a class="headerlink" href="#trimesh.base.Trimesh.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_convex: bool</strong></dt>
<dd><p class="first last">Is mesh convex or not</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_empty">
<code class="descname">is_empty</code><a class="headerlink" href="#trimesh.base.Trimesh.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the current mesh have data defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>empty</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, no data is set on the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_volume">
<code class="descname">is_volume</code><a class="headerlink" href="#trimesh.base.Trimesh.is_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh has all the properties required to represent
a valid volume, rather than just a surface.</p>
<p>These properties include being watertight, having consistent
winding and outward facing normals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Does the mesh represent a volume</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_watertight">
<code class="descname">is_watertight</code><a class="headerlink" href="#trimesh.base.Trimesh.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is watertight by making sure every edge is
included in two faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_watertight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Is mesh watertight or not</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_winding_consistent">
<code class="descname">is_winding_consistent</code><a class="headerlink" href="#trimesh.base.Trimesh.is_winding_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the mesh have consistent winding or not.
A mesh with consistent winding has each shared edge
going in an opposite direction from the other in the pair.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>consistent</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Is winding is consistent or not</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.kdtree">
<code class="descname">kdtree</code><a class="headerlink" href="#trimesh.base.Trimesh.kdtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.
Not cached as this lead to observed memory issues and segfaults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scipy.spatial.cKDTree</span></dt>
<dd><p class="first last">Contains mesh.vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.mass">
<code class="descname">mass</code><a class="headerlink" href="#trimesh.base.Trimesh.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass of the current mesh, based on specified density and
volume. If the current mesh isn’t watertight this is garbage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Mass of the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.mass_properties">
<code class="descname">mass_properties</code><a class="headerlink" href="#trimesh.base.Trimesh.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass properties of the current mesh.</p>
<p>Assumes uniform density, and result is probably garbage if mesh
isn’t watertight.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>properties</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">With keys:
‘volume’      : in global units^3
‘mass’        : From specified density
‘density’     : Included again for convenience (same as kwarg density)
‘inertia’     : Taken at the center of mass and aligned with global</p>
<blockquote>
<div><p>coordinate system</p>
</div></blockquote>
<p class="last">‘center_mass’ : Center of mass location, in global coordinate system</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the core geometry information for the mesh,
faces and vertices.</p>
<p>Generated from TrackedArray, which subclasses np.ndarray to monitor for
changes and returns a correct, but lazily evaluated md5 so it only has to
recalculate the hash occasionally, rather than on every call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">MD5 of everything in the DataStore</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.merge_vertices">
<code class="descname">merge_vertices</code><span class="sig-paren">(</span><em>distance=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has vertices that are closer than
trimesh.constants.tol.merge reindex faces to reference
the same index for both vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">If specified overrides tol.merge</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.moment_inertia">
<code class="descname">moment_inertia</code><a class="headerlink" href="#trimesh.base.Trimesh.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the moment of inertia matrix of the current mesh.
If mesh isn’t watertight this is garbage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inertia</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) float</span></dt>
<dd><p class="first last">Moment of inertia of the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.outline">
<code class="descname">outline</code><span class="sig-paren">(</span><em>face_ids=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of face ids, find the outline of the faces,
and return it as a Path3D.</p>
<p>The outline is defined here as every edge which is only
included by a single triangle.</p>
<p>Note that this implies a non-watertight section,
and the ‘outline’ of a watertight mesh is an empty path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>face_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n) int</span></dt>
<dd><p class="first last">Indices to compute the outline of.
If None, outline of full mesh will be computed.</p>
</dd>
<dt><strong>**kwargs: passed to Path3D constructor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Path3D</span></dt>
<dd><p class="first last">Curve in 3D of the outline</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.principal_inertia_components">
<code class="descname">principal_inertia_components</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal components of inertia</p>
<p>Ordering corresponds to mesh.principal_inertia_vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>components</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Principal components of inertia</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.principal_inertia_transform">
<code class="descname">principal_inertia_transform</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A transform which moves the current mesh so the principal
inertia vectors are on the X,Y, and Z axis, and the centroid is
at the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4, 4) float</span></dt>
<dd><p class="first last">Homogenous transformation matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.principal_inertia_vectors">
<code class="descname">principal_inertia_vectors</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal axis of inertia.</p>
<p>Ordering corresponds to mesh.principal_inertia_components</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) float</span></dt>
<dd><p class="first last">Three vectors pointing along the
principal axis of inertia directions</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.process">
<code class="descname">process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the bare minimum processing to make a mesh useful.</p>
<dl class="docutils">
<dt>Does this by:</dt>
<dd><ol class="first last arabic simple">
<li>removing NaN and Inf values</li>
<li>merging duplicate vertices</li>
</ol>
</dd>
<dt>If self._validate:</dt>
<dd><ol class="first last arabic simple" start="3">
<li>Remove triangles which have one edge of their rectangular 2D
oriented bounding box shorter than tol.merge</li>
<li>remove duplicated triangles</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self: trimesh.Trimesh</strong></dt>
<dd><p class="first last">Current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.register">
<code class="descname">register</code><span class="sig-paren">(</span><em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh object</span></dt>
<dd><p class="first last">Mesh to align with other</p>
</dd>
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh or (n, 3) float</span></dt>
<dd><p class="first last">Mesh or points in space</p>
</dd>
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of samples from mesh surface to align</p>
</dd>
<dt><strong>icp_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many ICP iterations for the 9 possible
combinations of</p>
</dd>
<dt><strong>icp_final</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many ICP itertations for the closest
candidate from the wider search</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh_to_other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4, 4) float</span></dt>
<dd><p class="first last">Transform to align mesh to the other object</p>
</dd>
<dt><strong>cost</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Average square distance per point</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_degenerate_faces">
<code class="descname">remove_degenerate_faces</code><span class="sig-paren">(</span><em>height=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_degenerate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove degenerate faces (faces without 3 unique vertex indices)
from the current mesh.</p>
<p>If a height is specified, it will remove any face with a 2D oriented
bounding box with one edge shorter than that height.</p>
<p>If not specified, it will remove any face with a zero normal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>height</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">If specified removes faces with an oriented bounding
box shorter than this on one side.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nondegenerate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.faces),) bool</span></dt>
<dd><p class="first last">Mask used to remove faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_duplicate_faces">
<code class="descname">remove_duplicate_faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_duplicate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>On the current mesh remove any faces which are duplicates.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_infinite_values">
<code class="descname">remove_infinite_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_infinite_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that every vertex and face consists of finite numbers.</p>
<p>This will remove vertices or faces containing np.nan and np.inf</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_unreferenced_vertices">
<code class="descname">remove_unreferenced_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_unreferenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all vertices in the current mesh which are not
referenced by a face.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.rezero">
<code class="descname">rezero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.rezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the mesh so that all vertex vertices are positive.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>count</em>, <em>return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples distributed normally across the
surface of the mesh</p>
<dl class="docutils">
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of points to sample</dd>
<dt>return_index <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True will also return the index of which face each
sample was taken from.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(count, 3) float</span></dt>
<dd><p class="first last">Points on surface of mesh</p>
</dd>
<dt><strong>face_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(count, ) int</span></dt>
<dd><p class="first last">Index of self.faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.scale">
<code class="descname">scale</code><a class="headerlink" href="#trimesh.base.Trimesh.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>A metric for the overall scale of the mesh, the length of the
diagonal of the axis aligned bounding box of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The length of the meshes AABB diagonal</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.scene">
<code class="descname">scene</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Scene object containing the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scene</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.scene.scene.Scene</span></dt>
<dd><p class="first last">Contains just the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.section">
<code class="descname">section</code><span class="sig-paren">(</span><em>plane_normal</em>, <em>plane_origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3D cross section of the current mesh and a plane
defined by origin and normal.</p>
<dl class="docutils">
<dt>plane_normal: (3) vector for plane normal</dt>
<dd>Normal vector of section plane</dd>
<dt>plane_origin <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd>Point on the cross section plane</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intersections: Path3D or None</strong></dt>
<dd><p class="first last">Curve of intersection</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.section_multiplane">
<code class="descname">section_multiplane</code><span class="sig-paren">(</span><em>plane_origin</em>, <em>plane_normal</em>, <em>heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.section_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multiple parallel cross sections of the current
mesh in 2D.</p>
<dl class="docutils">
<dt>plane_normal: (3) vector for plane normal</dt>
<dd>Normal vector of section plane</dd>
<dt>plane_origin <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd>Point on the cross section plane</dd>
<dt>heights <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd>Each section is offset by height along
the plane normal.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>paths</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) Path2D or None</span></dt>
<dd><p class="first last">2D cross sections at specified heights.
path.metadata[‘to_3D’] contains transform
to return 2D section back into 3D space.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the mesh in an opengl window. Requires pyglet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Run smooth shading on mesh or not,
large meshes will be slow</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scene</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.scene.Scene</span></dt>
<dd><p class="first last">Scene with current mesh in it</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.smoothed">
<code class="descname">smoothed</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of the current mesh which will render nicely.
Does not change current mesh in any way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle in radians, face pairs with angles smaller than
this value will appear smoothed</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>smoothed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Non watertight version of current mesh
which will render nicely with smooth shading</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Trimesh objects, based on face connectivity.
Splits into individual components, sometimes referred to as ‘bodies’</p>
<dl class="docutils">
<dt>only_watertight <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Only return watertight meshes and discard remainder</dd>
<dt>adjacency <span class="classifier-delimiter">:</span> <span class="classifier">None or (n, 2) int</span></dt>
<dd>Override face adjacency with custom values</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>meshes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) trimesh.Trimesh</span></dt>
<dd><p class="first last">Separate bodies from original mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.subdivide">
<code class="descname">subdivide</code><span class="sig-paren">(</span><em>face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh, with each subdivided face replaced with four
smaller faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>face_index: (m,) int or None</strong></dt>
<dd><p class="first last">If None all faces of mesh will be subdivided
If (m,) int array of indices: only specified faces will be
subdivided. Note that in this case the mesh will generally
no longer be manifold, as the additional vertex on the midpoint
will not be used by the adjacent faces to the faces specified,
and an additional postprocessing step will be required to
make resulting mesh watertight</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.submesh">
<code class="descname">submesh</code><span class="sig-paren">(</span><em>faces_sequence</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>faces_sequence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence (m,) int</span></dt>
<dd><p class="first last">Face indices of mesh</p>
</dd>
<dt><strong>only_watertight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Only return submeshes which are watertight</p>
</dd>
<dt><strong>append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Return a single mesh which has the faces appended.
if this flag is set, only_watertight is ignored</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>if append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh object</span></dt>
<dd></dd>
<dt><strong>else</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of trimesh.Trimesh objects</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.symmetry">
<code class="descname">symmetry</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>symmetry: None         No rotational symmetry</strong></dt>
<dd><p class="first last">‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.symmetry_axis">
<code class="descname">symmetry_axis</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axis: (3,) float</strong></dt>
<dd><p class="first last">Axis around which a 2D profile
was revolved to generate this mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.symmetry_section">
<code class="descname">symmetry_section</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry_section" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the two
vectors which make up a section coordinate frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>section: (2, 3) float, vectors to take a section along</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the current mesh, with keys
that can be used as the kwargs for the Trimesh constructor, eg:</p>
<p>a = Trimesh(<a href="#id1"><span class="problematic" id="id2">**</span></a>other_mesh.to_dict())</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">With keys that match trimesh constructor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles">
<code class="descname">triangles</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Actual triangles of the mesh (points, not indexes)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>triangles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3, 3) float</span></dt>
<dd><p class="first last">Points of triangle vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles_center">
<code class="descname">triangles_center</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>triangles_center</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.faces), 3) float</span></dt>
<dd><p class="first last">Center of each triangular face</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles_cross">
<code class="descname">triangles_cross</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>The cross product of two edges of each triangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>crosses</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Cross product of each triangle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles_tree">
<code class="descname">triangles_tree</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree containing each face of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">rtree.index</span></dt>
<dd><p class="first last">Each triangle in self.faces has a rectangular cell</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>other</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean union between this mesh and n other meshes</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh, or list of trimesh.Trimesh objects</span></dt>
<dd>Other meshes to union</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>union</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Union of self and other Trimesh objects</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.units">
<code class="descname">units</code><a class="headerlink" href="#trimesh.base.Trimesh.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of units for the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unit system mesh is in, or None if not defined</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.unmerge_vertices">
<code class="descname">unmerge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.unmerge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all face references so that every face contains three
unique vertex indices and no faces are adjacent.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.update_faces">
<code class="descname">update_faces</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.update_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>In many cases, we will want to remove specific faces.
However, there is additional bookkeeping to do this cleanly.
This function updates the set of faces with a validity mask,
as well as keeping track of normals and colors.</p>
<dl class="docutils">
<dt>valid <span class="classifier-delimiter">:</span> <span class="classifier">(m) int or (len(self.faces)) bool</span></dt>
<dd>Mask to remove faces</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.update_vertices">
<code class="descname">update_vertices</code><span class="sig-paren">(</span><em>mask</em>, <em>inverse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.update_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vertices with a mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.vertices)) bool</span></dt>
<dd><p class="first last">Array of which vertices to keep</p>
</dd>
<dt><strong>inverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.vertices)) int</span></dt>
<dd><p class="first last">Array to reconstruct vertex references
such as output by np.unique</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_adjacency_graph">
<code class="descname">vertex_adjacency_graph</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and their connections
in the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>graph: networkx.Graph</strong></dt>
<dd><p class="first last">Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<p>mesh = trimesh.primitives.Box()
graph = mesh.vertex_adjacency_graph
graph.neighbors(0)
&gt; [1,2,3,4]</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_defects">
<code class="descname">vertex_defects</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_defect</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.vertices), ) float</span></dt>
<dd><p class="first last">Vertex defect at the every vertex</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_neighbors">
<code class="descname">vertex_neighbors</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex neighbors of each vertex of the mesh, determined from
the cached vertex_adjacency_graph, if already existent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_neighbors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.vertices),) int</span></dt>
<dd><p class="first last">Represents immediate neighbors of each vertex along
the edge of a triangle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">Box</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1,2,3,4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_normals">
<code class="descname">vertex_normals</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex normals of the mesh. If the normals were loaded
we check to make sure we have the same number of vertex
normals and vertices before returning them. If there are
no vertex normals defined or a shape mismatch we  calculate
the vertex normals from the mean normals of the faces the
vertex is used in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_normals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Represents the surface normal at each vertex.
Where n == len(self.vertices)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertices">
<code class="descname">vertices</code><a class="headerlink" href="#trimesh.base.Trimesh.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertices of the mesh.</p>
<p>This is regarded as core information which cannot be
generated from cache and as such is stored in self._data
which tracks the array for changes and clears cached
values of the mesh if this is altered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Points in cartesian space referenced by self.faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.base.Trimesh.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current mesh calculated using a surface
integral. If the current mesh isn’t watertight this is
garbage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>volume</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Volume of the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.voxelized">
<code class="descname">voxelized</code><span class="sig-paren">(</span><em>pitch</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.voxelized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Voxel object representing the current mesh
discretized into voxels at the specified pitch</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pitch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The edge length of a single voxel</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>voxelized</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Voxel object</span></dt>
<dd><p class="first last">Representing the current mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.boolean">
<span id="trimesh-boolean-module"></span><h2>trimesh.boolean module<a class="headerlink" href="#module-trimesh.boolean" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.boolean.boolean_automatic">
<code class="descclassname">trimesh.boolean.</code><code class="descname">boolean_automatic</code><span class="sig-paren">(</span><em>meshes</em>, <em>operation</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.boolean_automatic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="trimesh.boolean.difference">
<code class="descclassname">trimesh.boolean.</code><code class="descname">difference</code><span class="sig-paren">(</span><em>meshes</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean difference between a mesh an n other meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meshes: list of Trimesh object</strong></dt>
<dd></dd>
<dt><strong>engine: string, which backend to use.</strong></dt>
<dd><p class="first last">valid choices are ‘blender’ or ‘scad’</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>difference: a - (other meshes), **kwargs for a Trimesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.intersection">
<code class="descclassname">trimesh.boolean.</code><code class="descname">intersection</code><span class="sig-paren">(</span><em>meshes</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean intersection between a mesh an n other meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meshes: list of Trimesh object</strong></dt>
<dd></dd>
<dt><strong>engine: string, which backend to use.</strong></dt>
<dd><p class="first last">valid choices are ‘blender’ or ‘scad’</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intersection: **kwargs for a Trimesh object of the</strong></dt>
<dd><p class="first last">volume that is contained by all meshes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.union">
<code class="descclassname">trimesh.boolean.</code><code class="descname">union</code><span class="sig-paren">(</span><em>meshes</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean union between a mesh an n other meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meshes: list of Trimesh object</strong></dt>
<dd></dd>
<dt><strong>engine: string, which backend to use.</strong></dt>
<dd><p class="first last">valid choices are ‘blender’ or ‘scad’</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>union: a + (other meshes), **kwargs for a Trimesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-trimesh.bounds">
<span id="trimesh-bounds-module"></span><h2>trimesh.bounds module<a class="headerlink" href="#module-trimesh.bounds" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.bounds.contains">
<code class="descclassname">trimesh.bounds.</code><code class="descname">contains</code><span class="sig-paren">(</span><em>bounds</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Do an axis aligned bounding box check on a list of points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2, dimension) float</span></dt>
<dd><p class="first last">Axis aligned bounding box</p>
</dd>
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, dimension) float</span></dt>
<dd><p class="first last">Points in space</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points_inside</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) bool</span></dt>
<dd><p class="first last">True if points are inside the AABB</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.corners">
<code class="descclassname">trimesh.bounds.</code><code class="descname">corners</code><span class="sig-paren">(</span><em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pair of axis aligned bounds, return all
8 corners of the bounding box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2,3) or (2,2) float</span></dt>
<dd><p class="first last">Axis aligned bounds</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corners</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(8,3) float</span></dt>
<dd><p class="first last">Corner vertices of the cube</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.minimum_cylinder">
<code class="descclassname">trimesh.bounds.</code><code class="descname">minimum_cylinder</code><span class="sig-paren">(</span><em>obj</em>, <em>sample_count=10</em>, <em>angle_tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.minimum_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the approximate minimum volume cylinder which contains
a mesh or a a list of points.</p>
<p>Samples a hemisphere then uses scipy.optimize to pick the
final orientation of the cylinder.</p>
<p>A nice discussion about better ways to implement this is here:
<a class="reference external" href="https://www.staff.uni-mainz.de/schoemer/publications/ALGO00.pdf">https://www.staff.uni-mainz.de/schoemer/publications/ALGO00.pdf</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh, or (n, 3) float</span></dt>
<dd><p class="first last">Mesh object or points in space</p>
</dd>
<dt><strong>sample_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How densely should we sample the hemisphere.
Angular spacing is 180 degrees / this number</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><dl class="first last docutils">
<dt>With keys:</dt>
<dd><p class="first">‘radius’    : float, radius of cylinder
‘height’    : float, height of cylinder
‘transform’ : (4,4) float, transform from the origin</p>
<blockquote class="last">
<div><p>to centered cylinder</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.oriented_bounds">
<code class="descclassname">trimesh.bounds.</code><code class="descname">oriented_bounds</code><span class="sig-paren">(</span><em>obj</em>, <em>angle_digits=1</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.oriented_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the oriented bounding box for a Trimesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh, (n, 2) float, or (n, 3) float</span></dt>
<dd><p class="first last">Mesh object or points in 2D or 3D space</p>
</dd>
<dt><strong>angle_digits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How much angular precision do we want on our result.
Even with less precision the returned extents will cover
the mesh albeit with larger than minimal volume, and may
experience substantial speedups.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>to_origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4,4) float</span></dt>
<dd><p class="first last">Transformation matrix which will move the center of the
bounding box of the input mesh to the origin.</p>
</dd>
<dt><strong>extents: (3,) float</strong></dt>
<dd><p class="first last">The extents of the mesh once transformed with to_origin</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.oriented_bounds_2D">
<code class="descclassname">trimesh.bounds.</code><code class="descname">oriented_bounds_2D</code><span class="sig-paren">(</span><em>points</em>, <em>qhull_options='QbB'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.oriented_bounds_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an oriented bounding box for an array of 2D points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,2) float</span></dt>
<dd><p class="first last">Points in 2D.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,3) float</span></dt>
<dd><p class="first last">Homogenous 2D transformation matrix to move the
input points so that the axis aligned bounding box
is CENTERED AT THE ORIGIN.</p>
</dd>
<dt><strong>rectangle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2,) float</span></dt>
<dd><p class="first last">Size of extents once input points are transformed
by transform</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-trimesh.caching">
<span id="trimesh-caching-module"></span><h2>trimesh.caching module<a class="headerlink" href="#module-trimesh.caching" title="Permalink to this headline">¶</a></h2>
<div class="section" id="caching-py">
<h3>caching.py<a class="headerlink" href="#caching-py" title="Permalink to this headline">¶</a></h3>
<p>Functions and classes that help with tracking changes in ndarrays
and clearing cached values based on those changes.</p>
<dl class="class">
<dt id="trimesh.caching.Cache">
<em class="property">class </em><code class="descclassname">trimesh.caching.</code><code class="descname">Cache</code><span class="sig-paren">(</span><em>id_function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to cache values which will be stored until the
result of an ID function changes.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.Cache.clear" title="trimesh.caching.Cache.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>([exclude])</td>
<td>Remove all elements in the cache.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.caching.Cache.delete" title="trimesh.caching.Cache.delete"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete</span></code></a>(key)</td>
<td>Remove a key from the cache.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.Cache.id_set" title="trimesh.caching.Cache.id_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">id_set</span></code></a>()</td>
<td>Set the current ID to the value of the ID function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.caching.Cache.update" title="trimesh.caching.Cache.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(items)</td>
<td>Update the cache with a set of key, value pairs without checking id_function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.Cache.verify" title="trimesh.caching.Cache.verify"><code class="xref py py-obj docutils literal notranslate"><span class="pre">verify</span></code></a>()</td>
<td>Verify that the cached values are still for the same value of id_function and delete all stored items if the value of id_function has changed.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.caching.Cache.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements in the cache.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a key from the cache.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.id_set">
<code class="descname">id_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.id_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current ID to the value of the ID function.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the cache with a set of key, value pairs without
checking id_function.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.verify">
<code class="descname">verify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that the cached values are still for the same
value of id_function and delete all stored items if
the value of id_function has changed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.caching.DataStore">
<em class="property">class </em><code class="descclassname">trimesh.caching.</code><code class="descname">DataStore</code><a class="headerlink" href="#trimesh.caching.DataStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to store multiple numpy arrays and track them all
for changes.</p>
<p>Operates like a dict that only stores numpy.ndarray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mutable</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.DataStore.clear" title="trimesh.caching.DataStore.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</td>
<td>Remove all data from the DataStore.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.caching.DataStore.crc" title="trimesh.caching.DataStore.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</td>
<td>Get a CRC reflecting everything in the DataStore.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.DataStore.fast_hash" title="trimesh.caching.DataStore.fast_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_hash</span></code></a>()</td>
<td>Get a CRC32 or xxhash.xxh64 reflecting the DataStore.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.caching.DataStore.is_empty" title="trimesh.caching.DataStore.is_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></a>()</td>
<td>Is the current DataStore empty or not.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.DataStore.md5" title="trimesh.caching.DataStore.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</td>
<td>Get an MD5 reflecting everything in the DataStore.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>update</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>values</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.caching.DataStore.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all data from the DataStore.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a CRC reflecting everything in the DataStore.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>crc: int, CRC of data</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.fast_hash">
<code class="descname">fast_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.fast_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a CRC32 or xxhash.xxh64 reflecting the DataStore.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hashed: int, checksum of data</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the current DataStore empty or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>empty: bool, False if there are items in the DataStore</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 reflecting everything in the DataStore.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5: str, MD5 in hexadecimal</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.caching.DataStore.mutable">
<code class="descname">mutable</code><a class="headerlink" href="#trimesh.caching.DataStore.mutable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.caching.TrackedArray">
<em class="property">class </em><code class="descclassname">trimesh.caching.</code><code class="descname">TrackedArray</code><a class="headerlink" href="#trimesh.caching.TrackedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
<p>Subclass of numpy.ndarray that provides hash methods
to track changes.</p>
<p>General method is to aggressively set ‘modified’ flags
on operations which might (but don’t necessarily) alter
the array, ideally we sometimes compute hashes when we
don’t need to, but we don’t return wrong hashes ever.</p>
<p>We store boolean modified flag for each hash type to
make checks fast even for queries of different hashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt>
<dd><p class="first last">Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd><p class="first last">Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt>
<dd><p class="first last">An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd><p class="first last">Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd><p class="first last">Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first last">Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt>
<dd><p class="first last">A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt>
<dd><p class="first last">The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt>
<dd><p class="first last">Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt>
<dd><p class="first last">Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt>
<dd><p class="first last">Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt>
<dd><p class="first last">The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt>
<dd><p class="first last">Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd><p class="first last">Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt>
<dd><p class="first last">Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.TrackedArray.md5" title="trimesh.caching.TrackedArray.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</td>
<td>Return an MD5 hash of the current array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.caching.TrackedArray.crc" title="trimesh.caching.TrackedArray.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</td>
<td>A zlib.crc32 or zlib.adler32 checksum of the current data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.caching.TrackedArray.fast_hash" title="trimesh.caching.TrackedArray.fast_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_hash</span></code></a>()</td>
<td>An xxhash.b64 hash of the array.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.caching.TrackedArray.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.crc32 or zlib.adler32 checksum
of the current data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>crc: int, checksum from zlib.crc32 or zlib.adler32</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.fast_hash">
<code class="descname">fast_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.fast_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>An xxhash.b64 hash of the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>xx: int, xxhash.xxh64 hash of array.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an MD5 hash of the current array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5: str, hexadecimal MD5 of the array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.caching.cache_decorator">
<code class="descclassname">trimesh.caching.</code><code class="descname">cache_decorator</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.cache_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator for class methods, replaces &#64;property
but will store and retrieve function return values
in object cache.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>function</strong> <span class="classifier-delimiter">:</span> <span class="classifier">class method</span></dt>
<dd><dl class="first last docutils">
<dt>This is used as a decorator:</dt>
<dd><p class="first">&#64;cache_decorator
def foo(self, things):</p>
<blockquote class="last">
<div><p>return ‘happy days’</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.caching.tracked_array">
<code class="descclassname">trimesh.caching.</code><code class="descname">tracked_array</code><span class="sig-paren">(</span><em>array</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.tracked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Properly subclass a numpy ndarray to track changes.</p>
<p>Avoids some pitfalls of subclassing by forcing contiguous
arrays, and does a view into a TrackedArray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>array: array- like object to be turned into a TrackedArray</strong></dt>
<dd></dd>
<dt><strong>dtype: which dtype to use for the array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tracked: TrackedArray, of input array data</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.collision">
<span id="trimesh-collision-module"></span><h2>trimesh.collision module<a class="headerlink" href="#module-trimesh.collision" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.collision.CollisionManager">
<em class="property">class </em><code class="descclassname">trimesh.collision.</code><code class="descname">CollisionManager</code><a class="headerlink" href="#trimesh.collision.CollisionManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A mesh-mesh collision manager.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.add_object" title="trimesh.collision.CollisionManager.add_object"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_object</span></code></a>(name,&nbsp;mesh[,&nbsp;transform])</td>
<td>Add an object to the collision manager.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.in_collision_internal" title="trimesh.collision.CollisionManager.in_collision_internal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_collision_internal</span></code></a>([return_names,&nbsp;…])</td>
<td>Check if any pair of objects in the manager collide with one another.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.in_collision_other" title="trimesh.collision.CollisionManager.in_collision_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_collision_other</span></code></a>(other_manager[,&nbsp;…])</td>
<td>Check if any object from this manager collides with any object from another manager.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.in_collision_single" title="trimesh.collision.CollisionManager.in_collision_single"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_collision_single</span></code></a>(mesh[,&nbsp;transform,&nbsp;…])</td>
<td>Check a single object for collisions against all objects in the manager.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.min_distance_internal" title="trimesh.collision.CollisionManager.min_distance_internal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_distance_internal</span></code></a>([return_names,&nbsp;…])</td>
<td>Get the minimum distance between any pair of objects in the manager.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.min_distance_other" title="trimesh.collision.CollisionManager.min_distance_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_distance_other</span></code></a>(other_manager[,&nbsp;…])</td>
<td>Get the minimum distance between any pair of objects, one in each manager.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.min_distance_single" title="trimesh.collision.CollisionManager.min_distance_single"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_distance_single</span></code></a>(mesh[,&nbsp;transform,&nbsp;…])</td>
<td>Get the minimum distance between a single object and any object in the manager.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.remove_object" title="trimesh.collision.CollisionManager.remove_object"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_object</span></code></a>(name)</td>
<td>Delete an object from the collision manager.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.CollisionManager.set_transform" title="trimesh.collision.CollisionManager.set_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_transform</span></code></a>(name,&nbsp;transform)</td>
<td>Set the transform for one of the manager’s objects.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.collision.CollisionManager.add_object">
<code class="descname">add_object</code><span class="sig-paren">(</span><em>name</em>, <em>mesh</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.add_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an object to the collision manager.</p>
<p>If an object with the given name is already in the manager,
replace it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name:      str, an identifier for the object</strong></dt>
<dd></dd>
<dt><strong>mesh:      Trimesh object, the geometry of the collision object</strong></dt>
<dd></dd>
<dt><strong>transform: (4,4) float, homogenous transform matrix for the object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_internal">
<code class="descname">in_collision_internal</code><span class="sig-paren">(</span><em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any pair of objects in the manager collide with one another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>return_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool If true, a set is returned containing the names</span></dt>
<dd><p class="first last">of all pairs of objects in collision.</p>
</dd>
<dt><strong>return_data:  bool, If true, a list of ContactData is returned as well</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_collision: bool,  True if a collision occurred between any pair of objects</strong></dt>
<dd><p class="first last">and False otherwise</p>
</dd>
<dt><strong>names: set of 2-tup, The set of pairwise collisions. Each tuple</strong></dt>
<dd><p class="first last">contains two names in alphabetical order indicating
that the two corresponding objects are in collision.</p>
</dd>
<dt><strong>contacts: list of ContactData, All contacts detected</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_other">
<code class="descname">in_collision_other</code><span class="sig-paren">(</span><em>other_manager</em>, <em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any object from this manager collides with any object from another manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other_manager: CollisionManager, another collision manager object</strong></dt>
<dd></dd>
<dt><strong>return_names:  bool,             If true, a set is returned containing the names</strong></dt>
<dd><p class="first last">of all pairs of objects in collision.</p>
</dd>
<dt><strong>return_data:   bool,             If true, a list of ContactData is returned as well</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_collision: bool,  True if a collision occurred between any pair of objects</strong></dt>
<dd><p class="first last">and False otherwise</p>
</dd>
<dt><strong>names: set of 2-tup, The set of pairwise collisions. Each tuple</strong></dt>
<dd><p class="first last">contains two names (first from this manager,
second from the other_manager) indicating
that the two corresponding objects are in collision.</p>
</dd>
<dt><strong>contacts: list of ContactData, All contacts detected</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_single">
<code class="descname">in_collision_single</code><span class="sig-paren">(</span><em>mesh</em>, <em>transform=None</em>, <em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a single object for collisions against all objects in the
manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:         Trimesh object, the geometry of the collision object</strong></dt>
<dd></dd>
<dt><strong>transform:    (4,4) float,    homogenous transform matrix</strong></dt>
<dd></dd>
<dt><strong>return_names: bool,           If true, a set is returned containing the names</strong></dt>
<dd><p class="first last">of all objects in collision with the object</p>
</dd>
<dt><strong>return_data:  bool,           If true, a list of ContactData is returned as well</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_collision: bool,            True if a collision occurs and False otherwise</strong></dt>
<dd></dd>
<dt><strong>names: set of str,             The set of names of objects that collided with the</strong></dt>
<dd><p class="first last">provided one</p>
</dd>
<dt><strong>contacts: list of ContactData, All contacts detected</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_internal">
<code class="descname">min_distance_internal</code><span class="sig-paren">(</span><em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between any pair of objects in the manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>return_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, If true, a 2-tuple is returned containing the names</span></dt>
<dd><p class="first last">of the closest objects.</p>
</dd>
<dt><strong>return_data:  bool,  If true, a DistanceData object is returned as well</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance: float,    Min distance between any two managed objects</strong></dt>
<dd></dd>
<dt><strong>names: (2,) str,    The names of the closest objects</strong></dt>
<dd></dd>
<dt><strong>data: DistanceData, Extra data about the distance query</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_other">
<code class="descname">min_distance_other</code><span class="sig-paren">(</span><em>other_manager</em>, <em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between any pair of objects, one in each manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other_manager: CollisionManager, another collision manager object</strong></dt>
<dd></dd>
<dt><strong>return_names:  bool,             If true, a 2-tuple is returned containing</strong></dt>
<dd><p class="first last">the names of the closest objects.</p>
</dd>
<dt><strong>return_data:   bool,             If true, a DistanceData object is returned as well</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance: float,     The min distance between a pair of objects,</strong></dt>
<dd><p class="first last">one from each manager.</p>
</dd>
<dt><strong>names: 2-tup of str, A 2-tuple containing two names (first from this manager,</strong></dt>
<dd><p class="first last">second from the other_manager) indicating
the two closest objects.</p>
</dd>
<dt><strong>data: DistanceData,  Extra data about the distance query</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_single">
<code class="descname">min_distance_single</code><span class="sig-paren">(</span><em>mesh</em>, <em>transform=None</em>, <em>return_name=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between a single object and any object in the
manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:         Trimesh object, the geometry of the collision object</strong></dt>
<dd></dd>
<dt><strong>transform:    (4,4) float,    homogenous transform matrix for the object</strong></dt>
<dd></dd>
<dt><strong>return_names: bool,           If true, return name of the closest object</strong></dt>
<dd></dd>
<dt><strong>return_data:  bool,           If true, a DistanceData object is returned as well</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance: float,    Min distance between mesh and any object in the manager</strong></dt>
<dd></dd>
<dt><strong>name: str,          The name of the object in the manager that was closest</strong></dt>
<dd></dd>
<dt><strong>data: DistanceData, Extra data about the distance query</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.remove_object">
<code class="descname">remove_object</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.remove_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete an object from the collision manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name: str, the identifier for the object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.set_transform">
<code class="descname">set_transform</code><span class="sig-paren">(</span><em>name</em>, <em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.set_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transform for one of the manager’s objects.
This replaces the prior transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name:      str, an identifier for the object already in the manager</strong></dt>
<dd></dd>
<dt><strong>transform: (4,4) float, a new homogenous transform matrix for the object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.collision.ContactData">
<em class="property">class </em><code class="descclassname">trimesh.collision.</code><code class="descname">ContactData</code><span class="sig-paren">(</span><em>names</em>, <em>contact</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.ContactData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Data structure for holding information about a collision contact.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.collision.ContactData.point" title="trimesh.collision.ContactData.point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">point</span></code></a></dt>
<dd><p class="first last">The 3D point of intersection for this contact.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.ContactData.index" title="trimesh.collision.ContactData.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(name)</td>
<td>Returns the index of the face in contact for the mesh with the given name.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.collision.ContactData.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.ContactData.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the face in contact for the mesh with
the given name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name: str, the name of the target object.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index: int, the index of the face in collisoin.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.collision.ContactData.point">
<code class="descname">point</code><a class="headerlink" href="#trimesh.collision.ContactData.point" title="Permalink to this definition">¶</a></dt>
<dd><p>The 3D point of intersection for this contact.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>point: (3,) float, the intersection point.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.collision.DistanceData">
<em class="property">class </em><code class="descclassname">trimesh.collision.</code><code class="descname">DistanceData</code><span class="sig-paren">(</span><em>names</em>, <em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Data structure for holding information about a distance query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.collision.DistanceData.distance" title="trimesh.collision.DistanceData.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a></dt>
<dd><p class="first last">Returns the distance between the two objects.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.collision.DistanceData.index" title="trimesh.collision.DistanceData.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(name)</td>
<td>Returns the index of the closest face for the mesh with the given name.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.collision.DistanceData.point" title="trimesh.collision.DistanceData.point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">point</span></code></a>(name)</td>
<td>The 3D point of closest distance on the mesh with the given name.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.collision.DistanceData.distance">
<code class="descname">distance</code><a class="headerlink" href="#trimesh.collision.DistanceData.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance between the two objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance: float, the euclidean distance between the objects.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.DistanceData.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the closest face for the mesh with
the given name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name: str, the name of the target object.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index: int, the index of the face in collisoin.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.DistanceData.point">
<code class="descname">point</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData.point" title="Permalink to this definition">¶</a></dt>
<dd><p>The 3D point of closest distance on the mesh with the given name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name: str, the name of the target object.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>point: (3,) float, the closest point.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.collision.mesh_to_BVH">
<code class="descclassname">trimesh.collision.</code><code class="descname">mesh_to_BVH</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.mesh_to_BVH" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a BVHModel object from a Trimesh object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bvh: fcl.BVHModel object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.collision.scene_to_collision">
<code class="descclassname">trimesh.collision.</code><code class="descname">scene_to_collision</code><span class="sig-paren">(</span><em>scene</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.scene_to_collision" title="Permalink to this definition">¶</a></dt>
<dd><p>Create collision objects from a trimesh.Scene object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>scene: trimesh.Scene object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>manager: CollisionManager object</strong></dt>
<dd></dd>
<dt><strong>objects: {node name: CollisionObject}</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-trimesh.comparison">
<span id="trimesh-comparison-module"></span><h2>trimesh.comparison module<a class="headerlink" href="#module-trimesh.comparison" title="Permalink to this headline">¶</a></h2>
<div class="section" id="comparison-py">
<h3>comparison.py<a class="headerlink" href="#comparison-py" title="Permalink to this headline">¶</a></h3>
<p>Provide methods for quickly hashing and comparing meshes.</p>
<dl class="function">
<dt id="trimesh.comparison.identifier_hash">
<code class="descclassname">trimesh.comparison.</code><code class="descname">identifier_hash</code><span class="sig-paren">(</span><em>identifier</em>, <em>sigfig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.identifier_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash an identifier array to a specified number of significant figures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>identifier: (n,) float</strong></dt>
<dd></dd>
<dt><strong>sigfig:     (n,) int</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5: str, MD5 hash of identifier</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.comparison.identifier_simple">
<code class="descclassname">trimesh.comparison.</code><code class="descname">identifier_simple</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.identifier_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a basic identifier for a mesh, consisting of properties
that have been hand tuned to be somewhat robust to rigid
transformations and different tesselations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>identifier: (6,) float, identifying values of the mesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.constants">
<span id="trimesh-constants-module"></span><h2>trimesh.constants module<a class="headerlink" href="#module-trimesh.constants" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.constants.NumericalResolutionPath">
<em class="property">class </em><code class="descclassname">trimesh.constants.</code><code class="descname">NumericalResolutionPath</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.NumericalResolutionPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="docutils">
<dt>res.seg_frac: when discretizing curves, what percentage of the drawing</dt>
<dd>scale should we aim to make a single segment</dd>
</dl>
<p>res.seg_angle: when discretizing curves, what angle should a section span
res.max_sections: when discretizing splines, what is the maximum number</p>
<blockquote>
<div>of segments per control point</div></blockquote>
<dl class="docutils">
<dt>res.min_sections: when discretizing splines, what is the minimum number</dt>
<dd>of segments per control point</dd>
</dl>
<p>res.export: format string to use when exporting floating point vertices</p>
</dd></dl>

<dl class="class">
<dt id="trimesh.constants.NumericalToleranceMesh">
<em class="property">class </em><code class="descclassname">trimesh.constants.</code><code class="descname">NumericalToleranceMesh</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.NumericalToleranceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>tol.zero: consider floating point numbers less than this zero</p>
<dl class="docutils">
<dt>tol.merge: when merging vertices, consider vertices closer than this</dt>
<dd>to be the same vertex. Here we use the same value (1e-8)
as SolidWorks uses, according to their documentation.</dd>
<dt>tol.planar: the maximum distance from a plane a point can be and</dt>
<dd>still be considered to be on the plane</dd>
</dl>
<p>tol.facet_threshold: threshold for two facets to be considered coplanar</p>
</dd></dl>

<dl class="class">
<dt id="trimesh.constants.NumericalTolerancePath">
<em class="property">class </em><code class="descclassname">trimesh.constants.</code><code class="descname">NumericalTolerancePath</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.NumericalTolerancePath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>tol.zero: consider floating point numbers less than this zero
tol.merge: when merging vertices, consider vertices closer than this</p>
<blockquote>
<div>to be the same vertex</div></blockquote>
<dl class="docutils">
<dt>tol.planar: the maximum distance from a plane a point can be and</dt>
<dd>still be considered to be on the plane</dd>
<dt>tol.seg_frac: when simplifying line segments what percentage of the drawing</dt>
<dd>scale can a segment be and have a curve fitted</dd>
<dt>tol.seg_angle: when simplifying line segments to arcs, what angle</dt>
<dd>can a segment span to be acceptable.</dd>
<dt>tol.aspect_frac: when simplifying line segments to closed arcs (circles)</dt>
<dd>what percentage can the aspect ratio differfrom 1:1
before escaping the fit early</dd>
<dt>tol.radius_frac: when simplifying line segments to arcs, what percentage</dt>
<dd>of the fit radius can vertices deviate to be acceptable</dd>
<dt>tol.radius_min: when simplifying line segments to arcs, what is the minimum</dt>
<dd>radius multiplied by document scale for an acceptable fit</dd>
<dt>tol.radius_max: when simplifying line segments to arcs, what is the maximum</dt>
<dd>radius multiplied by document scale for an acceptable fit</dd>
<dt>tol.tangent: when simplifying line segments to curves, what is the maximum</dt>
<dd>angle the end sections can deviate from tangent that is acceptable.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.convex">
<span id="trimesh-convex-module"></span><h2>trimesh.convex module<a class="headerlink" href="#module-trimesh.convex" title="Permalink to this headline">¶</a></h2>
<p>convex.py</p>
<p>Deal with creating and checking convex objects in 2, 3 and N dimensions.</p>
<p>Convex:
1) “Convex, meaning “curving out” or “extending outward” (compare to concave)
2) having an outline or surface curved like the exterior of a circle or sphere.
3) (of a polygon) having only interior angles measuring less than 180</p>
<dl class="function">
<dt id="trimesh.convex.adjacency_projections">
<code class="descclassname">trimesh.convex.</code><code class="descname">adjacency_projections</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a mesh is convex by projecting the vertices of
a triangle onto the normal of its adjacent face.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>projection: distance of projection of adjacent vertex onto plane</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.convex_hull">
<code class="descclassname">trimesh.convex.</code><code class="descname">convex_hull</code><span class="sig-paren">(</span><em>obj</em>, <em>qhull_options='QbB Pp'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of the
current mesh, with proper normals and watertight.
Requires scipy &gt;.12.</p>
<p>obj: Trimesh object OR
(n,3) float, cartesian points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>convex: Trimesh object of convex hull</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.hull_points">
<code class="descclassname">trimesh.convex.</code><code class="descname">hull_points</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.hull_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract a convex set of points from multiple input formats.</p>
<dl class="docutils">
<dt>obj: Trimesh object</dt>
<dd>(n,d) points
(m,) Trimesh objects</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points: (o,d) convex set of points</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.is_convex">
<code class="descclassname">trimesh.convex.</code><code class="descname">is_convex</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>convex: bool, was passed mesh convex or not</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-trimesh.creation">
<span id="trimesh-creation-module"></span><h2>trimesh.creation module<a class="headerlink" href="#module-trimesh.creation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creation-py">
<h3>creation.py<a class="headerlink" href="#creation-py" title="Permalink to this headline">¶</a></h3>
<p>Create meshes from primitives, or with operations.</p>
<dl class="function">
<dt id="trimesh.creation.annulus">
<code class="descclassname">trimesh.creation.</code><code class="descname">annulus</code><span class="sig-paren">(</span><em>r_min=1.0</em>, <em>r_max=2.0</em>, <em>height=1.0</em>, <em>sections=32</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.annulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of an annular cylinder along Z,
centered at the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The inner radius of the annular cylinder</p>
</dd>
<dt><strong>r_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The outer radius of the annular cylinder</p>
</dd>
<dt><strong>height</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height of the annular cylinder</p>
</dd>
<dt><strong>sections</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many pie wedges should the annular cylinder have</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>annulus</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Mesh of annular cylinder</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.box">
<code class="descclassname">trimesh.creation.</code><code class="descname">box</code><span class="sig-paren">(</span><em>extents=None</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.box" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cuboid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>extents: float, or (3,) float edge length</strong></dt>
<dd></dd>
<dt><strong>transform: (4, 4) float, transformation matrix</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>box: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.capsule">
<code class="descclassname">trimesh.creation.</code><code class="descname">capsule</code><span class="sig-paren">(</span><em>height=1.0, radius=1.0, count=[32, 32]</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of a capsule, or a cylinder with hemispheric ends.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>height: float, center to center distance of two spheres</strong></dt>
<dd></dd>
<dt><strong>radius: float, radius of the cylinder and hemispheres</strong></dt>
<dd></dd>
<dt><strong>count:  (2,) int, number of sections on latitude and longitude</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>capsule: Trimesh of capsule with given properties</strong></dt>
<dd><ul class="first last simple">
<li>cylinder axis is along Z</li>
<li>one hemisphere is centered at the origin</li>
<li>other hemisphere is centered along the Z axis at specified height</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.cylinder">
<code class="descclassname">trimesh.creation.</code><code class="descname">cylinder</code><span class="sig-paren">(</span><em>radius=1.0</em>, <em>height=1.0</em>, <em>sections=32</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of a cylinder along Z centered at the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The radius of the cylinder</p>
</dd>
<dt><strong>height</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height of the cylinder</p>
</dd>
<dt><strong>sections</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many pie wedges should the cylinder have</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cylinder: Trimesh, resulting mesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.extrude_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">extrude_polygon</code><span class="sig-paren">(</span><em>polygon</em>, <em>height</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.extrude_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a 2D shapely polygon into a 3D mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>polygon: shapely.geometry.Polygon object</strong></dt>
<dd></dd>
<dt><strong>height:  float, distance to extrude polygon along Z</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh: Trimesh object of result</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.extrude_triangulation">
<code class="descclassname">trimesh.creation.</code><code class="descname">extrude_triangulation</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>height</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.extrude_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a 2D triangulation into a watertight Trimesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) float</span></dt>
<dd><p class="first last">2D vertices</p>
</dd>
<dt><strong>faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, 3) int</span></dt>
<dd><p class="first last">Triangle indexes of vertices</p>
</dd>
<dt><strong>height</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Distance to extrude triangulation</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Mesh created from extrusion</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.icosahedron">
<code class="descclassname">trimesh.creation.</code><code class="descname">icosahedron</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.icosahedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an icosahedron, a 20 faced polyhedron.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.icosphere">
<code class="descclassname">trimesh.creation.</code><code class="descname">icosphere</code><span class="sig-paren">(</span><em>subdivisions=3</em>, <em>radius=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.icosphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an isophere centered at the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>subdivisions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many times to subdivide the mesh.
Note that the number of faces will grow as function of
4 ** subdivisions, so you probably want to keep this under ~5</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Desired radius of sphere</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ico</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Meshed sphere</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.random_soup">
<code class="descclassname">trimesh.creation.</code><code class="descname">random_soup</code><span class="sig-paren">(</span><em>face_count=100</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.random_soup" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random set of triangles as a Trimesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>face_count: int, number of faces in resultant mesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>soup: Trimesh object with face_count random faces</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.sweep_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">sweep_polygon</code><span class="sig-paren">(</span><em>polygon</em>, <em>path</em>, <em>angles=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.sweep_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a 2D shapely polygon into a watertight 3D mesh
along an arbitrary 3D path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>polygon: shapely.geometry.Polygon object</strong></dt>
<dd></dd>
<dt><strong>path:    (n,3) float, a path in 3D</strong></dt>
<dd></dd>
<dt><strong>angles:  (n,) float, optional rotation angle relative to prior vertex</strong></dt>
<dd><p class="first last">at each vertex</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object of result</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.triangulate_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">triangulate_polygon</code><span class="sig-paren">(</span><em>polygon</em>, <em>triangle_args='pq0D'</em>, <em>engine='auto'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.triangulate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a shapely polygon create a triangulation using one of
the python interfaces to triangle.c:
pip install meshpy
pip install triangle</p>
<dl class="docutils">
<dt>polygon <span class="classifier-delimiter">:</span> <span class="classifier">Shapely.geometry.Polygon</span></dt>
<dd>Polygon object to be triangulated</dd>
<dt>triangle_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Passed to triangle.triangulate</dd>
<dt>engine <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>‘meshpy’, ‘triangle’, or ‘auto’</dd>
<dt>kwargs: passed directly to meshpy.triangle.build:</dt>
<dd><dl class="first last docutils">
<dt>triangle.build(mesh_info,</dt>
<dd>verbose=False,
refinement_func=None,
attributes=False,
volume_constraints=True,
max_volume=None,
allow_boundary_steiner=True,
allow_volume_steiner=True,
quality_meshing=True,
generate_edges=None,
generate_faces=False,
min_angle=None)</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>vertices <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) float</span></dt>
<dd>Points in space</dd>
<dt>faces <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) int</span></dt>
<dd>Index of vertices that make up triangles</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.uv_sphere">
<code class="descclassname">trimesh.creation.</code><code class="descname">uv_sphere</code><span class="sig-paren">(</span><em>radius=1.0, count=[32, 32], theta=None, phi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.uv_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UV sphere (latitude + longitude) centered at the origin.</p>
<p>Roughly one order of magnitude faster than an icosphere but slightly uglier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radius of sphere</p>
</dd>
<dt><strong>count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2,) int</span></dt>
<dd><p class="first last">Number of latitude and longitude lines</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">Optional theta angles in radians</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">Optional phi angles in radians</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Mesh of UV sphere with specified parameters</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.validate_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">validate_polygon</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.validate_polygon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.curvature">
<span id="trimesh-curvature-module"></span><h2>trimesh.curvature module<a class="headerlink" href="#module-trimesh.curvature" title="Permalink to this headline">¶</a></h2>
<div class="section" id="curvature-py">
<h3>curvature.py<a class="headerlink" href="#curvature-py" title="Permalink to this headline">¶</a></h3>
<p>Query mesh curvature.</p>
<dl class="function">
<dt id="trimesh.curvature.discrete_gaussian_curvature_measure">
<code class="descclassname">trimesh.curvature.</code><code class="descname">discrete_gaussian_curvature_measure</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.discrete_gaussian_curvature_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete gaussian curvature measure of a sphere centered
at a point as detailed in ‘Restricted Delaunay triangulations and normal
cycle’, Cohen-Steiner and Morvan.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, the sphere radius</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gaussian_curvature: (n,) float, discrete gaussian curvature measure.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.discrete_mean_curvature_measure">
<code class="descclassname">trimesh.curvature.</code><code class="descname">discrete_mean_curvature_measure</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.discrete_mean_curvature_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete mean curvature measure of a sphere centered
at a point as detailed in ‘Restricted Delaunay triangulations and normal
cycle’, Cohen-Steiner and Morvan.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, the sphere radius</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mean_curvature: (n,) float, discrete mean curvature measure.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.face_angles">
<code class="descclassname">trimesh.curvature.</code><code class="descname">face_angles</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.face_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle at each vertex of a face.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>angles: (n, 3) float, angle at each vertex of a face.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.face_angles_sparse">
<code class="descclassname">trimesh.curvature.</code><code class="descname">face_angles_sparse</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sparse: scipy.sparse.coo_matrix with:</strong></dt>
<dd><p class="first last">dtype: float
shape: (len(mesh.vertices), len(mesh.faces))</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.line_ball_intersection">
<code class="descclassname">trimesh.curvature.</code><code class="descname">line_ball_intersection</code><span class="sig-paren">(</span><em>start_points</em>, <em>end_points</em>, <em>center</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.line_ball_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the length of the intersection of a line segment with a ball.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>start_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>end_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>center</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float, the sphere center</span></dt>
<dd></dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, the sphere radius</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lengths: (n,) float, the lengths.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.sphere_ball_intersection">
<code class="descclassname">trimesh.curvature.</code><code class="descname">sphere_ball_intersection</code><span class="sig-paren">(</span><em>R</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.sphere_ball_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the surface area of the intersection of sphere of radius R centered
at (0, 0, 0) with a ball of radius r centered at (R, 0, 0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, sphere radius</span></dt>
<dd></dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, ball radius</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area: float, the surface are.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.vertex_defects">
<code class="descclassname">trimesh.curvature.</code><code class="descname">vertex_defects</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_defect</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.vertices), ) float</span></dt>
<dd><p class="first last">Vertex defect at the every vertex</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.decomposition">
<span id="trimesh-decomposition-module"></span><h2>trimesh.decomposition module<a class="headerlink" href="#module-trimesh.decomposition" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.decomposition.convex_decomposition">
<code class="descclassname">trimesh.decomposition.</code><code class="descname">convex_decomposition</code><span class="sig-paren">(</span><em>mesh</em>, <em>engine=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.decomposition.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:   Trimesh object</strong></dt>
<dd></dd>
<dt><strong>engine: string, which backend to use. Valid choice is ‘vhacd’.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh_args: list, list of **kwargs for Trimeshes that are nearly</strong></dt>
<dd><p class="first last">convex and approximate the original.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.decomposition.decomposition_automatic">
<code class="descclassname">trimesh.decomposition.</code><code class="descname">decomposition_automatic</code><span class="sig-paren">(</span><em>mesh</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.decomposition.decomposition_automatic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-trimesh.geometry">
<span id="trimesh-geometry-module"></span><h2>trimesh.geometry module<a class="headerlink" href="#module-trimesh.geometry" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.geometry.align_vectors">
<code class="descclassname">trimesh.geometry.</code><code class="descname">align_vectors</code><span class="sig-paren">(</span><em>vector_start</em>, <em>vector_end</em>, <em>return_angle=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.align_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 4x4 transformation matrix which will rotate from
vector_start to vector_end, eg:</p>
<p>vector_end == np.dot(T, np.append(vector_start, 1))[0:3]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vector_start: (3,) float, vector in space</strong></dt>
<dd></dd>
<dt><strong>vector_end:   (3,) float, vector in space</strong></dt>
<dd></dd>
<dt><strong>return_angle: bool, return angle between vectors or not</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform: (4,4) float, transformation matrix</strong></dt>
<dd></dd>
<dt><strong>angle:     float, angle in radians (only returned if flag set)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.faces_to_edges">
<code class="descclassname">trimesh.geometry.</code><code class="descname">faces_to_edges</code><span class="sig-paren">(</span><em>faces</em>, <em>return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.faces_to_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of faces (n,3), return a list of edges (n*3,2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>faces: (n,3) int, vertex indices representing faces</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>edges: (n*3, 2) int, vertex indices representing edges</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.index_sparse">
<code class="descclassname">trimesh.geometry.</code><code class="descname">index_sparse</code><span class="sig-paren">(</span><em>column_count</em>, <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.index_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sparse matrix for which vertices are contained in which faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sparse: scipy.sparse.coo_matrix of shape (column_count, len(faces))</strong></dt>
<dd><p class="first last">dtype is boolean</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [1]: sparse = faces_sparse(len(mesh.vertices), mesh.faces)</p>
<p>In [2]: sparse.shape
Out[2]: (12, 20)</p>
<p>In [3]: mesh.faces.shape
Out[3]: (20, 3)</p>
<p>In [4]: mesh.vertices.shape
Out[4]: (12, 3)</p>
<p>In [5]: dense = sparse.toarray().astype(int)</p>
<p>In [6]: dense
Out[6]:
array([[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</p>
<blockquote>
<div>[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0],
[0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1],
[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0],
[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1],
[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1]])</div></blockquote>
<p>In [7]: dense.sum(axis=0)
Out[7]: array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.mean_vertex_normals">
<code class="descclassname">trimesh.geometry.</code><code class="descname">mean_vertex_normals</code><span class="sig-paren">(</span><em>vertex_count</em>, <em>faces</em>, <em>face_normals</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.mean_vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find vertex normals from the mean of the faces that contain that vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertex_count: int, the number of vertices faces refer to</strong></dt>
<dd></dd>
<dt><strong>faces:        (n,3) int, list of vertex indices</strong></dt>
<dd></dd>
<dt><strong>face_normals: (n,3) float, normal vector for each face</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_normals: (vertex_count, 3) float normals for every vertex</strong></dt>
<dd><p class="first last">Uncontained vertices will be zero.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.plane_transform">
<code class="descclassname">trimesh.geometry.</code><code class="descname">plane_transform</code><span class="sig-paren">(</span><em>origin</em>, <em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.plane_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the origin and normal of a plane find the transform
that will move that plane to be coplanar with the XY plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Point that lies on the plane</p>
</dd>
<dt><strong>normal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Vector that points along normal of plane</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform: (4,4) float</strong></dt>
<dd><p class="first last">Transformation matrix to move points onto XY plane</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.triangulate_quads">
<code class="descclassname">trimesh.geometry.</code><code class="descname">triangulate_quads</code><span class="sig-paren">(</span><em>quads</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.triangulate_quads" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of quad faces, return them as triangle faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>quads: (n,4) int, vertex indices of quad faces</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>faces: (m,3) int, vertex indices of triangular faces</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.vector_angle">
<code class="descclassname">trimesh.geometry.</code><code class="descname">vector_angle</code><span class="sig-paren">(</span><em>pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.vector_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the angles between vector pairs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pairs: (n,2,3) set of unit vector pairs</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>angles: (n,) float, angles between vectors</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>angles = mesh.face_normals[mesh.face_adjacency]</p>
</dd></dl>

</div>
<div class="section" id="module-trimesh.graph">
<span id="trimesh-graph-module"></span><h2>trimesh.graph module<a class="headerlink" href="#module-trimesh.graph" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph-py">
<h3>graph.py<a class="headerlink" href="#graph-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with graph operations. Primarily deal with graphs in (n,2)
edge list form, and abstract the backend graph library being used.</p>
<p>Currently uses networkx, scipy.sparse.csgraph, or graph_tool
backends.</p>
<dl class="function">
<dt id="trimesh.graph.connected_component_labels">
<code class="descclassname">trimesh.graph.</code><code class="descname">connected_component_labels</code><span class="sig-paren">(</span><em>edges</em>, <em>node_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_component_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Label graph nodes from an edge list, using scipy.sparse.csgraph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) int</span></dt>
<dd><p class="first last">Edges of a graph</p>
</dd>
<dt><strong>node_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, or None</span></dt>
<dd><p class="first last">The largest node in the graph.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(node_count,) int</span></dt>
<dd><p class="first last">Component labels for each node</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.connected_components">
<code class="descclassname">trimesh.graph.</code><code class="descname">connected_components</code><span class="sig-paren">(</span><em>edges</em>, <em>min_len=1</em>, <em>nodes=None</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Find groups of connected nodes from an edge list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>edges:      (n,2) int, edges between nodes</strong></dt>
<dd></dd>
<dt><strong>nodes:      (m, ) int, list of nodes that exist</strong></dt>
<dd></dd>
<dt><strong>min_len:    int, minimum length of a component group to return</strong></dt>
<dd></dd>
<dt><strong>engine:     str, which graph engine to use.</strong></dt>
<dd><p class="first last">(‘networkx’, ‘scipy’, or ‘graphtool’)
If None, will automatically choose fastest available.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>components: (n,) sequence of lists, nodes which are connected</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.connected_edges">
<code class="descclassname">trimesh.graph.</code><code class="descname">connected_edges</code><span class="sig-paren">(</span><em>G</em>, <em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given graph G and list of nodes, return the list of edges that
are connected to nodes</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.edges_to_coo">
<code class="descclassname">trimesh.graph.</code><code class="descname">edges_to_coo</code><span class="sig-paren">(</span><em>edges</em>, <em>count=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.edges_to_coo" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an edge list, return a boolean scipy.sparse.coo_matrix
representing the edges in matrix form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,2) int</span></dt>
<dd><p class="first last">Edges of a graph</p>
</dd>
<dt><strong>count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The total number of nodes in the graph
if None: count = edges.max() + 1</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) any</span></dt>
<dd><p class="first last">Assign data to each edge, if None will
be bool True for each specified edge</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix: (count, count) scipy.sparse.coo_matrix</strong></dt>
<dd><p class="first last">Sparse COO</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency">
<code class="descclassname">trimesh.graph.</code><code class="descname">face_adjacency</code><span class="sig-paren">(</span><em>faces=None</em>, <em>mesh=None</em>, <em>return_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an (n,2) list of face indices.
Each pair of faces in the list shares an edge, making them adjacent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) int, or None</span></dt>
<dd><p class="first last">List of vertex indices representing triangles</p>
</dd>
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd><p class="first last">If passed will used cached edges instead of faces</p>
</dd>
<dt><strong>return_edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Return the edges shared by adjacent faces</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>adjacency</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,2) int</span></dt>
<dd><p class="first last">Indexes of faces that are adjacent</p>
</dd>
<dt><strong>edges: (m,2) int</strong></dt>
<dd><p class="first last">Only returned if return_edges is True
Indexes of vertices which make up the
edges shared by the adjacent faces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This is useful for lots of things such as finding
face- connected components:
&gt;&gt;&gt; graph = nx.Graph()
&gt;&gt;&gt; graph.add_edges_from(mesh.face_adjacency)
&gt;&gt;&gt; groups = nx.connected_components(graph_connected)</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency_radius">
<code class="descclassname">trimesh.graph.</code><code class="descname">face_adjacency_radius</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate radius between adjacent faces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.face_adjacency),) float</span></dt>
<dd><p class="first last">Approximate radius between faces
Parallel faces will have a value of np.inf</p>
</dd>
<dt><strong>span</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.face_adjacency),) float</span></dt>
<dd><p class="first last">Perpendicular projection distance of two
unshared vertices onto the shared edge</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency_unshared">
<code class="descclassname">trimesh.graph.</code><code class="descname">face_adjacency_unshared</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vid_unshared</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(mesh.face_adjacency), 2) int</span></dt>
<dd><p class="first last">Indexes of mesh.vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.facets">
<code class="descclassname">trimesh.graph.</code><code class="descname">facets</code><span class="sig-paren">(</span><em>mesh</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the list of parallel adjacent faces.</p>
<p>mesh :  trimesh.Trimesh
engine : str</p>
<blockquote>
<div>Which graph engine to use:
(‘scipy’, ‘networkx’, ‘graphtool’)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>facets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of (n,) int</span></dt>
<dd><p class="first last">Groups of face indexes of
parallel adjacent faces.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.fill_traversals">
<code class="descclassname">trimesh.graph.</code><code class="descname">fill_traversals</code><span class="sig-paren">(</span><em>traversals</em>, <em>edges</em>, <em>edges_hash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.fill_traversals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a traversal of a list of edges into a sequence of
traversals where every pair of consecutive node indexes
is an edge in a passed edge list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>traversals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of (m,) int</span></dt>
<dd><p class="first last">Node indexes of traversals of a graph</p>
</dd>
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) int</span></dt>
<dd><p class="first last">Pairs of connected node indexes</p>
</dd>
<dt><strong>edges_hash</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, or (n,) int</span></dt>
<dd><p class="first last">Edges sorted along axis 1 then hashed
using grouping.hashable_rows</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>splits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of (p,) int</span></dt>
<dd><p class="first last">Node indexes of connected traversals</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.graph_to_svg">
<code class="descclassname">trimesh.graph.</code><code class="descname">graph_to_svg</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.graph_to_svg" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a networkx graph into an SVG string, using graphviz dot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>graph: networkx graph</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>svg: string, pictoral layout in SVG format</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.is_watertight">
<code class="descclassname">trimesh.graph.</code><code class="descname">is_watertight</code><span class="sig-paren">(</span><em>edges</em>, <em>edges_sorted=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><p>edges:        (n, 2) int, set of vertex indices
edges_sorted: (n, 2) int, vertex indices sorted on axis 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>watertight: boolean, whether every edge is shared by an even</strong></dt>
<dd><p class="first last">number of faces</p>
</dd>
<dt><strong>winding:    boolean, whether every shared edge is reversed</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.multigraph_collect">
<code class="descclassname">trimesh.graph.</code><code class="descname">multigraph_collect</code><span class="sig-paren">(</span><em>G</em>, <em>traversal</em>, <em>attrib=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.multigraph_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a MultiDiGraph traversal, collect attributes along it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>G:          networkx.MultiDiGraph</strong></dt>
<dd></dd>
<dt><strong>traversal:  (n) list of (node, instance) tuples</strong></dt>
<dd></dd>
<dt><strong>attrib:     dict key, name to collect. If None, will return all</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>collected: (len(traversal) - 1) list of attributes</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.multigraph_paths">
<code class="descclassname">trimesh.graph.</code><code class="descname">multigraph_paths</code><span class="sig-paren">(</span><em>G</em>, <em>source</em>, <em>cutoff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.multigraph_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>For a networkx MultiDiGraph, find all paths from a source node
to leaf nodes. This function returns edge instance numbers
in addition to nodes, unlike networkx.all_simple_paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>G: networkx.MultiDiGraph</strong></dt>
<dd></dd>
<dt><strong>source: str, node to start off</strong></dt>
<dd></dd>
<dt><strong>cutoff: int, number of nodes to visit</strong></dt>
<dd><p class="first last">if None, will</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traversals: (n,) list of [(node, edge instance index), ] paths</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.shared_edges">
<code class="descclassname">trimesh.graph.</code><code class="descname">shared_edges</code><span class="sig-paren">(</span><em>faces_a</em>, <em>faces_b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.shared_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two sets of faces, find the edges which are in both sets.</p>
<p>faces_a: (n,3) int, set of faces
faces_b: (m,3) int, set of faces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shared: (p, 2) int, set of edges</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.smoothed">
<code class="descclassname">trimesh.graph.</code><code class="descname">smoothed</code><span class="sig-paren">(</span><em>mesh</em>, <em>angle</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a non- watertight version of the mesh which will
render nicely with smooth shading.</p>
<p>mesh:  Trimesh object
angle: float, angle in radians, adjacent faces which have normals</p>
<blockquote>
<div>below this angle will be smoothed.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>smooth: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.split">
<code class="descclassname">trimesh.graph.</code><code class="descname">split</code><span class="sig-paren">(</span><em>mesh</em>, <em>only_watertight=True</em>, <em>adjacency=None</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a mesh into multiple meshes from face connectivity.</p>
<p>If only_watertight is true, it will only return watertight meshes
and will attempt single triangle/quad repairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh</strong></dt>
<dd></dd>
<dt><strong>only_watertight: if True, only return watertight components</strong></dt>
<dd></dd>
<dt><strong>adjacency: (n,2) list of face adjacency to override using the plain</strong></dt>
<dd><p class="first last">adjacency calculated automatically.</p>
</dd>
<dt><strong>engine: str, which engine to use. (‘networkx’, ‘scipy’, or ‘graphtool’)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>meshes: list of Trimesh objects</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.split_traversal">
<code class="descclassname">trimesh.graph.</code><code class="descname">split_traversal</code><span class="sig-paren">(</span><em>traversal</em>, <em>edges</em>, <em>edges_hash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.split_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a traversal as a list of nodes, split the traversal
if a sequential index pair is not in the given edges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) int</span></dt>
<dd><p class="first last">Graph edge indexes</p>
</dd>
<dt><strong>traversal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) int</span></dt>
<dd><p class="first last">Traversal through edges</p>
</dd>
<dt><strong>edge_hash</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,)</span></dt>
<dd><p class="first last">Edges sorted on axis=1 and
passed to grouping.hashable_rows</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>split</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of (p,) int</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.traversals">
<code class="descclassname">trimesh.graph.</code><code class="descname">traversals</code><span class="sig-paren">(</span><em>edges</em>, <em>mode='bfs'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.traversals" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an edge list, generate a sequence of ordered
depth first search traversals, using scipy.csgraph routines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>edges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,2) int, undirected edges of a graph</span></dt>
<dd></dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, ‘bfs’, or ‘dfs’</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traversals: (m,) sequence of (p,) int,</strong></dt>
<dd><p class="first last">ordered DFS or BFS traversals of the graph.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.vertex_adjacency_graph">
<code class="descclassname">trimesh.graph.</code><code class="descname">vertex_adjacency_graph</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and
their connections in the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>graph</strong> <span class="classifier-delimiter">:</span> <span class="classifier">networkx.Graph</span></dt>
<dd><p class="first last">Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.
&gt;&gt;&gt; graph = mesh.vertex_adjacency_graph
&gt;&gt;&gt; graph.neighbors(0)
&gt; [1,3,4]</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.grouping">
<span id="trimesh-grouping-module"></span><h2>trimesh.grouping module<a class="headerlink" href="#module-trimesh.grouping" title="Permalink to this headline">¶</a></h2>
<div class="section" id="grouping-py">
<h3>grouping.py<a class="headerlink" href="#grouping-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for grouping values and rows.</p>
<dl class="function">
<dt id="trimesh.grouping.blocks">
<code class="descclassname">trimesh.grouping.</code><code class="descname">blocks</code><span class="sig-paren">(</span><em>data</em>, <em>min_len=2</em>, <em>max_len=inf</em>, <em>digits=None</em>, <em>only_nonzero=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array, find the indices of contiguous blocks
of equal values.</p>
<p>data:    (n) array
min_len: int, the minimum length group to be returned
max_len: int, the maximum length group to be retuurned
digits:  if dealing with floats, how many digits to use
only_nonzero: bool, only return blocks of non- zero values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>blocks: (m) sequence of indices referencing data</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.boolean_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">boolean_rows</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>operation=&lt;function intersect1d&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.boolean_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the rows in two arrays which occur in both rows.</p>
<dl class="docutils">
<dt>a: (n, d) int</dt>
<dd>Array with row vectors</dd>
<dt>b: (m, d) int</dt>
<dd>Array with row vectors</dd>
<dt>operation <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><dl class="first last docutils">
<dt>Numpy boolean set operation function:</dt>
<dd>-np.intersect1d
-np.setdiff1d</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shared: (p, d) array containing rows in both a and b</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.clusters">
<code class="descclassname">trimesh.grouping.</code><code class="descname">clusters</code><span class="sig-paren">(</span><em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Find clusters of points which have neighbours closer than radius</p>
<dl class="docutils">
<dt>points <span class="classifier-delimiter">:</span> <span class="classifier">(n, d) float</span></dt>
<dd>Points of dimension d</dd>
<dt>radius <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Max distance between points in a cluster</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) sequence of int</span></dt>
<dd><p class="first last">Indices of points in a cluster</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.float_to_int">
<code class="descclassname">trimesh.grouping.</code><code class="descname">float_to_int</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em>, <em>dtype=&lt;class 'numpy.int32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.float_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a numpy array of float/bool/int, return as integers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data:   (n, d) float, int, or bool data</strong></dt>
<dd></dd>
<dt><strong>digits: float/int precision for float conversion</strong></dt>
<dd></dd>
<dt><strong>dtype:  numpy dtype for result</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>as_int: data, as integers</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group</code><span class="sig-paren">(</span><em>values</em>, <em>min_len=0</em>, <em>max_len=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of values that are identical</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>values:     1D array</strong></dt>
<dd></dd>
<dt><strong>min_len:    int, the shortest group allowed</strong></dt>
<dd><p class="first last">All groups will have len &gt;= min_length</p>
</dd>
<dt><strong>max_len:    int, the longest group allowed</strong></dt>
<dd><p class="first last">All groups will have len &lt;= max_length</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>groups: sequence of indices to form groups</strong></dt>
<dd><p class="first last">IE [0,1,0,1] returns [[0,2], [1,3]]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_distance">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_distance</code><span class="sig-paren">(</span><em>values</em>, <em>distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find groups of points which have neighbours closer than radius,
where no two points in a group are farther than distance apart.</p>
<dl class="docutils">
<dt>points <span class="classifier-delimiter">:</span> <span class="classifier">(n, d) float</span></dt>
<dd>Points of dimension d</dd>
<dt>distance <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Max distance between points in a cluster</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>unique</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, d) float</span></dt>
<dd><p class="first last">Median value of each group</p>
</dd>
<dt><strong>groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m) sequence of int</span></dt>
<dd><p class="first last">Indexes of points that make up a group</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_min">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_min</code><span class="sig-paren">(</span><em>groups</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of groups, find the minimum element of data within each group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) sequence of (q,) int</span></dt>
<dd><p class="first last">Indexes of each group corresponding to each element in data</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)</span></dt>
<dd><p class="first last">The data that groups indexes reference</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>minimums</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,)</span></dt>
<dd><p class="first last">Minimum value of data per group</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_rows</code><span class="sig-paren">(</span><em>data</em>, <em>require_count=None</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns index groups of duplicate rows, for example:
[[1,2], [3,4], [1,2]] will return [[0,2], [1]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data:          (n,m) array</strong></dt>
<dd></dd>
<dt><strong>require_count: only returns groups of a specified length, eg:</strong></dt>
<dd><p class="first">require_count =  2
[[1,2], [3,4], [1,2]] will return [[0,2]]</p>
<p class="last">Note that using require_count allows numpy advanced indexing
to be used in place of looping and checking hashes, and as a
consequence is ~10x faster.</p>
</dd>
<dt><strong>digits:        If data is floating point, how many decimals to look at.</strong></dt>
<dd><p class="first last">If this is None, the value in TOL_MERGE will be turned into a
digit count and used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>groups:        List or sequence of indices from data indicating identical rows.</strong></dt>
<dd><p class="first last">If require_count != None, shape will be (j, require_count)
If require_count is None, shape will be irregular (AKA a sequence)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_vectors">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_vectors</code><span class="sig-paren">(</span><em>vectors</em>, <em>angle=0.0001</em>, <em>include_negative=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Group vectors based on an angle tolerance, with the option to
include negative vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Direction vector</p>
</dd>
<dt><strong>angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Group vectors closer than this angle in radians</p>
</dd>
<dt><strong>include_negative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True consider the same:
[0,0,1] and [0,0,-1]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3) float</span></dt>
<dd><p class="first last">Direction vector</p>
</dd>
<dt><strong>groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) sequence of int</span></dt>
<dd><p class="first last">Indices of source vectors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.hashable_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">hashable_rows</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.hashable_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>We turn our array into integers based on the precision
given by digits and then put them in a hashable format.</p>
<p>data:    (n,m) input array
digits:  how many digits to add to hash, if data is floating point</p>
<blockquote>
<div>If none, TOL_MERGE will be turned into a digit count and used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hashable:  (n) length array of custom data which can be sorted</strong></dt>
<dd><p class="first last">or used as hash keys</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.merge_runs">
<code class="descclassname">trimesh.grouping.</code><code class="descname">merge_runs</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.merge_runs" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge duplicate sequential values. This differs from unique_ordered
in that values can occur in multiple places in the sequence, but
only consecutive repeats are removed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data: (n,) float or int</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>merged: (m,) float or int</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [1]: a
Out[1]:
array([-1, -1, -1,  0,  0,  1,  1,  2,  0,</p>
<blockquote>
<div>3,  3,  4,  4,  5,  5,  6,  6,  7,
7,  8,  8,  9,  9,  9])</div></blockquote>
<p>In [2]: trimesh.grouping.merge_runs(a)
Out[2]: array([-1,  0,  1,  2,  0,  3,  4,  5,  6,  7,  8,  9])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.merge_vertices_hash">
<code class="descclassname">trimesh.grouping.</code><code class="descname">merge_vertices_hash</code><span class="sig-paren">(</span><em>mesh</em>, <em>distance=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.merge_vertices_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes duplicate vertices, based on integer hashes of
each row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd><p class="first last">Mesh to merge vertices of</p>
</dd>
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, or None</span></dt>
<dd><p class="first last">If not specified uses tol.merge</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_float">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_float</code><span class="sig-paren">(</span><em>data</em>, <em>return_index=False</em>, <em>return_inverse=False</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to the numpy.unique command, except evaluates floating point
numbers, using a specified number of digits.</p>
<p>If digits isn’t specified, the library default TOL_MERGE will be used.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_ordered">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_ordered</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_ordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the same as np.unique, but ordered as per the
first occurrence of the unique value in data.</p>
<p class="rubric">Examples</p>
<p>In [1]: a = [0, 3, 3, 4, 1, 3, 0, 3, 2, 1]</p>
<p>In [2]: np.unique(a)
Out[2]: array([0, 1, 2, 3, 4])</p>
<p>In [3]: trimesh.grouping.unique_ordered(a)
Out[3]: array([0, 3, 4, 1, 2])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_rows</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of unique rows. It will return the
first occurrence of a row that is duplicated:
[[1,2], [3,4], [1,2]] will return [0,1]</p>
<p>data: (n,m) set of floating point data
digits: how many digits to consider for the purposes of uniqueness</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>unique:  (j) array, index in data which is a unique row</strong></dt>
<dd></dd>
<dt><strong>inverse: (n) length array to reconstruct original</strong></dt>
<dd><p class="first last">example: unique[inverse] == data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_value_in_row">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_value_in_row</code><span class="sig-paren">(</span><em>data</em>, <em>unique=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_value_in_row" title="Permalink to this definition">¶</a></dt>
<dd><p>For a 2D array of integers find the position of a value in each
row which only occurs once. If there are more than one value per
row which occur once, the last one is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data:   (n,d) int</strong></dt>
<dd></dd>
<dt><strong>unique: (m) int, list of unique values contained in data.</strong></dt>
<dd><p class="first last">speedup purposes only, generated from np.unique if not passed</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: (n,d) bool, with one or zero True values per row.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<dl class="docutils">
<dt>In [0]: r = np.array([[-1,  1,  1],</dt>
<dd>[-1,  1, -1],
[-1,  1,  1],
[-1,  1, -1],
[-1,  1, -1]], dtype=np.int8)</dd>
</dl>
<p>In [1]: unique_value_in_row(r)
Out[1]:</p>
<blockquote>
<div><dl class="docutils">
<dt>array([[ True, False, False],</dt>
<dd>[False,  True, False],
[ True, False, False],
[False,  True, False],
[False,  True, False]], dtype=bool)</dd>
</dl>
</div></blockquote>
<p>In [2]: unique_value_in_row(r).sum(axis=1)
Out[2]: array([1, 1, 1, 1, 1])</p>
<p>In [3]: r[unique_value_in_row(r)]
Out[3]: array([-1,  1, -1,  1,  1], dtype=int8)</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.inertia">
<span id="trimesh-inertia-module"></span><h2>trimesh.inertia module<a class="headerlink" href="#module-trimesh.inertia" title="Permalink to this headline">¶</a></h2>
<div class="section" id="inertia-py">
<h3>inertia.py<a class="headerlink" href="#inertia-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for dealing with inertia tensors.</p>
<p>Results validated against known geometries and for internal
consistency.</p>
<dl class="function">
<dt id="trimesh.inertia.cylinder_inertia">
<code class="descclassname">trimesh.inertia.</code><code class="descname">cylinder_inertia</code><span class="sig-paren">(</span><em>mass</em>, <em>radius</em>, <em>height</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.cylinder_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inertia tensor of a cylinder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mass:      float, mass of cylinder</strong></dt>
<dd></dd>
<dt><strong>radius:    float, radius of cylinder</strong></dt>
<dd></dd>
<dt><strong>height:    float, height of cylinder</strong></dt>
<dd></dd>
<dt><strong>transform: (4,4) float, transformation of cylinder</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inertia: (3,3) float, inertia tensor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.principal_axis">
<code class="descclassname">trimesh.inertia.</code><code class="descname">principal_axis</code><span class="sig-paren">(</span><em>inertia</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.principal_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the principal components and principal axis
of inertia from the inertia tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>inertia: (3,3) float, inertia tensor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>components: (3,) float, principal components of inertia</strong></dt>
<dd></dd>
<dt><strong>vectors:    (3,3) float, row vectors pointing along</strong></dt>
<dd><p class="first last">the principal axes of inertia</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.radial_symmetry">
<code class="descclassname">trimesh.inertia.</code><code class="descname">radial_symmetry</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.radial_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>symmetry: None         No rotational symmetry</strong></dt>
<dd><p class="first last">‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p>
</dd>
<dt><strong>axis:     None, or (3,)   float</strong></dt>
<dd></dd>
<dt><strong>section:  None, or (3, 2) float</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.sphere_inertia">
<code class="descclassname">trimesh.inertia.</code><code class="descname">sphere_inertia</code><span class="sig-paren">(</span><em>mass</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.sphere_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inertia tensor of a sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mass:      float, mass of sphere</strong></dt>
<dd></dd>
<dt><strong>radius:    float, radius of sphere</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inertia: (3,3) float, inertia tensor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.transform_inertia">
<code class="descclassname">trimesh.inertia.</code><code class="descname">transform_inertia</code><span class="sig-paren">(</span><em>transform</em>, <em>inertia_tensor</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.transform_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an inertia tensor to a new frame.</p>
<p>More details in OCW PDF:
MIT16_07F09_Lec26.pdf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>transform:      (3,3) or (4,4) float, transformation matrix</strong></dt>
<dd></dd>
<dt><strong>inertia_tensor: (3,3) float, inertia tensor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformed: (3,3) float, inertia tensor in new frame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.integrate">
<span id="trimesh-integrate-module"></span><h2>trimesh.integrate module<a class="headerlink" href="#module-trimesh.integrate" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integrate-py">
<h3>integrate.py<a class="headerlink" href="#integrate-py" title="Permalink to this headline">¶</a></h3>
<p>Utilities for integrating functions over meshes surfaces.</p>
<dl class="function">
<dt id="trimesh.integrate.substitute_barycentric">
<code class="descclassname">trimesh.integrate.</code><code class="descname">substitute_barycentric</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.integrate.substitute_barycentric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="trimesh.integrate.symbolic_barycentric">
<code class="descclassname">trimesh.integrate.</code><code class="descname">symbolic_barycentric</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.integrate.symbolic_barycentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolically integrate a function(x,y,z) across a triangle or mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>function: string or sympy expression</strong></dt>
<dd><p class="first last">x, y, z will be replaced with a barycentric representation
and the the function is integrated across the triangle.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evaluator: numpy lambda function of result which takes a mesh</strong></dt>
<dd></dd>
<dt><strong>expr:      sympy expression of result</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [1]: function = ‘1’</p>
<p>In [2]: integrator, expr = integrate_barycentric(function)</p>
<p>In [3]: integrator
Out[3]: &lt;__main__.evaluator instance at 0x7f66cd2a6200&gt;</p>
<p>In [4]: expr
Out[4]: 1/2</p>
<p>In [5]: result  = integrator(mesh)</p>
<p>In [6]: mesh.area
Out[6]: 34.641016151377542</p>
<p>In [7]: result.sum()
Out[7]: 34.641016151377542</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.intersections">
<span id="trimesh-intersections-module"></span><h2>trimesh.intersections module<a class="headerlink" href="#module-trimesh.intersections" title="Permalink to this headline">¶</a></h2>
<div class="section" id="intersections-py">
<h3>intersections.py<a class="headerlink" href="#intersections-py" title="Permalink to this headline">¶</a></h3>
<p>Primarily mesh-plane intersections (slicing).</p>
<dl class="function">
<dt id="trimesh.intersections.mesh_multiplane">
<code class="descclassname">trimesh.intersections.</code><code class="descname">mesh_multiplane</code><span class="sig-paren">(</span><em>mesh</em>, <em>plane_origin</em>, <em>plane_normal</em>, <em>heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.mesh_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility function for slicing a mesh by multiple
parallel planes, which caches the dot product operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Geometry to be sliced by planes</p>
</dd>
<dt><strong>plane_normal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Normal vector of plane</p>
</dd>
<dt><strong>plane_origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Point on a plane</p>
</dd>
<dt><strong>heights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) float</span></dt>
<dd><p class="first last">Offset distances from plane to slice at</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) sequence of (n, 2, 2) float</span></dt>
<dd><p class="first last">Lines in space for m planes</p>
</dd>
<dt><strong>to_3D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, 4, 4) float</span></dt>
<dd><p class="first last">Transform to move each section back to 3D</p>
</dd>
<dt><strong>face_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) sequence of (n,) int</span></dt>
<dd><p class="first last">Indexes of mesh.faces for each segment</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.mesh_plane">
<code class="descclassname">trimesh.intersections.</code><code class="descname">mesh_plane</code><span class="sig-paren">(</span><em>mesh</em>, <em>plane_normal</em>, <em>plane_origin</em>, <em>return_faces=False</em>, <em>cached_dots=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.mesh_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a the intersections between a mesh and a plane,
returning a set of line segments on that plane.</p>
<dl class="docutils">
<dt>mesh <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd>Source mesh to slice</dd>
<dt>plane_normal <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd>Normal vector of plane to intersect with mesh</dd>
<dt>plane_origin:  (3,) float</dt>
<dd>Point on plane to intersect with mesh</dd>
<dt>return_faces:  bool</dt>
<dd>If True return face index each line is from</dd>
<dt>cached_dots <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd>If an external function has stored dot
products pass them here to avoid recomputing</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, 2, 3) float</span></dt>
<dd><p class="first last">List of 3D line segments in space</p>
</dd>
<dt><strong>face_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,) int</span></dt>
<dd><p class="first last">Index of mesh.faces for each line
Only returned if return_faces was True</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.plane_lines">
<code class="descclassname">trimesh.intersections.</code><code class="descname">plane_lines</code><span class="sig-paren">(</span><em>plane_origin</em>, <em>plane_normal</em>, <em>endpoints</em>, <em>line_segments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.plane_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane-line intersections</p>
<dl class="docutils">
<dt>plane_origin <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd>Point on plane</dd>
<dt>plane_normal <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd>Plane normal vector</dd>
<dt>endpoints <span class="classifier-delimiter">:</span> <span class="classifier">(2, n, 3) float</span></dt>
<dd>Points defining lines to be tested</dd>
<dt>line_segments <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, only returns intersections as valid if
vertices from endpoints are on different sides
of the plane.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intersections</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, 3) float</span></dt>
<dd><p class="first last">Cartesian intersection points</p>
</dd>
<dt><strong>valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) bool</span></dt>
<dd><p class="first last">Indicate whether a valid intersection exists
for each input line segment</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.planes_lines">
<code class="descclassname">trimesh.intersections.</code><code class="descname">planes_lines</code><span class="sig-paren">(</span><em>plane_origins</em>, <em>plane_normals</em>, <em>line_origins</em>, <em>line_directions</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.planes_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Given one line per plane, find the intersection points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>plane_origins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Point on each plane</p>
</dd>
<dt><strong>plane_normals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Normal vector of each plane</p>
</dd>
<dt><strong>line_origins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Point at origin of each line</p>
</dd>
<dt><strong>line_directions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Direction vector of each line</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>on_plane</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Points on specified planes</p>
</dd>
<dt><strong>valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) bool</span></dt>
<dd><p class="first last">Did plane intersect line or not</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.nsphere">
<span id="trimesh-nsphere-module"></span><h2>trimesh.nsphere module<a class="headerlink" href="#module-trimesh.nsphere" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nsphere-py">
<h3>nsphere.py<a class="headerlink" href="#nsphere-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for fitting and minimizing nspheres:
circles, spheres, hyperspheres, etc.</p>
<dl class="function">
<dt id="trimesh.nsphere.fit_nsphere">
<code class="descclassname">trimesh.nsphere.</code><code class="descname">fit_nsphere</code><span class="sig-paren">(</span><em>points</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.fit_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an n-sphere to a set of points using least squares.</p>
<p>points: (n,d) set of points
prior:  (d,) float, best guess for center of nsphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>center: (d), location of center</strong></dt>
<dd></dd>
<dt><strong>radius: float, mean radius across circle</strong></dt>
<dd></dd>
<dt><strong>error:  float, peak to peak value of deviation from mean radius</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.nsphere.is_nsphere">
<code class="descclassname">trimesh.nsphere.</code><code class="descname">is_nsphere</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.is_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a list of points is an nsphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points: (n,dimension) float, points in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>check: bool, True if input points are on an nsphere</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.nsphere.minimum_nsphere">
<code class="descclassname">trimesh.nsphere.</code><code class="descname">minimum_nsphere</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.minimum_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum n- sphere for a mesh or a set of points.</p>
<p>Uses the fact that the minimum n- sphere will be centered at one of
the vertices of the furthest site voronoi diagram, which is n*log(n)
but should be pretty fast due to using the scipy/qhull implementations
of convex hulls and voronoi diagrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj: Trimesh object OR</strong></dt>
<dd><p class="first last">(n,d) float, set of points</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>center: (d) float, center of n- sphere</strong></dt>
<dd></dd>
<dt><strong>radius: float, radius of n-sphere</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.permutate">
<span id="trimesh-permutate-module"></span><h2>trimesh.permutate module<a class="headerlink" href="#module-trimesh.permutate" title="Permalink to this headline">¶</a></h2>
<div class="section" id="permutate-py">
<h3>permutate.py<a class="headerlink" href="#permutate-py" title="Permalink to this headline">¶</a></h3>
<p>Randomly deform meshes in different ways.</p>
<dl class="class">
<dt id="trimesh.permutate.Permutator">
<em class="property">class </em><code class="descclassname">trimesh.permutate.</code><code class="descname">Permutator</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.permutate.Permutator.noise" title="trimesh.permutate.Permutator.noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">noise</span></code></a>([magnitude])</td>
<td>Add gaussian noise to every vertex of a mesh.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.permutate.Permutator.tessellation" title="trimesh.permutate.Permutator.tessellation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tessellation</span></code></a>()</td>
<td>Subdivide each face of a mesh into three faces with the new vertex randomly placed inside the old face.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.permutate.Permutator.transform" title="trimesh.permutate.Permutator.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>()</td>
<td>Return a permutated variant of a mesh by randomly reording faces and rotatating + translating a mesh by a random matrix.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.permutate.Permutator.noise">
<code class="descname">noise</code><span class="sig-paren">(</span><em>magnitude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise to every vertex of a mesh.
Makes no effort to maintain topology or sanity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:      Trimesh object (will not be mutated)</strong></dt>
<dd></dd>
<dt><strong>magnitude: float, what is the maximum distance per axis we can displace a vertex.</strong></dt>
<dd><p class="first last">Default value is mesh.scale/100.0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>permutated: Trimesh object, input mesh with noise applied</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.permutate.Permutator.tessellation">
<code class="descname">tessellation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.tessellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide each face of a mesh into three faces with the new vertex
randomly placed inside the old face.</p>
<p>This produces a mesh with exactly the same surface area and volume
but with different tessellation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>permutated: Trimesh object with remeshed facets</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.permutate.Permutator.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a permutated variant of a mesh by randomly reording faces
and rotatating + translating a mesh by a random matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:   Trimesh object (input will not be altered by this function)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>permutated: Trimesh object, same faces as input mesh but</strong></dt>
<dd><p class="first last">rotated and reordered.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.noise">
<code class="descclassname">trimesh.permutate.</code><code class="descname">noise</code><span class="sig-paren">(</span><em>mesh</em>, <em>magnitude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise to every vertex of a mesh.
Makes no effort to maintain topology or sanity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:      Trimesh object (will not be mutated)</strong></dt>
<dd></dd>
<dt><strong>magnitude: float, what is the maximum distance per axis we can displace a vertex.</strong></dt>
<dd><p class="first last">Default value is mesh.scale/100.0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>permutated: Trimesh object, input mesh with noise applied</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.tessellation">
<code class="descclassname">trimesh.permutate.</code><code class="descname">tessellation</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.tessellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide each face of a mesh into three faces with the new vertex
randomly placed inside the old face.</p>
<p>This produces a mesh with exactly the same surface area and volume
but with different tessellation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>permutated: Trimesh object with remeshed facets</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.transform">
<code class="descclassname">trimesh.permutate.</code><code class="descname">transform</code><span class="sig-paren">(</span><em>mesh</em>, <em>translation_scale=1000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a permutated variant of a mesh by randomly reording faces
and rotatating + translating a mesh by a random matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:   Trimesh object (input will not be altered by this function)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>permutated: Trimesh object, same faces as input mesh but</strong></dt>
<dd><p class="first last">rotated and reordered.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.points">
<span id="trimesh-points-module"></span><h2>trimesh.points module<a class="headerlink" href="#module-trimesh.points" title="Permalink to this headline">¶</a></h2>
<div class="section" id="points-py">
<h3>points.py<a class="headerlink" href="#points-py" title="Permalink to this headline">¶</a></h3>
<p>Functions dealing with (n, d) points.</p>
<dl class="class">
<dt id="trimesh.points.PointCloud">
<em class="property">class </em><code class="descclassname">trimesh.points.</code><code class="descname">PointCloud</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Hold 3D points in an object which can be visualized
in a scene.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.points.PointCloud.bounds" title="trimesh.points.PointCloud.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt>
<dd><p class="first last">The axis aligned bounds of the PointCloud</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.centroid" title="trimesh.points.PointCloud.centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></a></dt>
<dd><p class="first last">The mean vertex position</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.colors" title="trimesh.points.PointCloud.colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">colors</span></code></a></dt>
<dd><p class="first last">Stored per- point color</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.convex_hull" title="trimesh.points.PointCloud.convex_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></a></dt>
<dd><p class="first last">A convex hull of every point.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.extents" title="trimesh.points.PointCloud.extents"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></a></dt>
<dd><p class="first last">The size of the axis aligned bounds</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.shape" title="trimesh.points.PointCloud.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd><p class="first last">Get the shape of the pointcloud</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.vertices" title="trimesh.points.PointCloud.vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></a></dt>
<dd><p class="first last">Vertices of the PointCloud</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.points.PointCloud.apply_transform" title="trimesh.points.PointCloud.apply_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code></a>(transform)</td>
<td>Apply a homogenous transformation to the PointCloud object in- place.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.points.PointCloud.md5" title="trimesh.points.PointCloud.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</td>
<td>Get an MD5 hash of the current vertices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.points.PointCloud.merge_vertices" title="trimesh.points.PointCloud.merge_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code></a>()</td>
<td>Merge vertices closer than tol.merge (default: 1e-8)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.points.PointCloud.scene" title="trimesh.points.PointCloud.scene"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code></a>()</td>
<td>A scene containing just the PointCloud</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.points.PointCloud.show" title="trimesh.points.PointCloud.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>()</td>
<td>Open a viewer window displaying the current PointCloud</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.points.PointCloud.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a homogenous transformation to the PointCloud
object in- place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4, 4) float</span></dt>
<dd><p class="first last">Homogenous transformation to apply to PointCloud</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.points.PointCloud.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the PointCloud</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2, 3) float</span></dt>
<dd><p class="first last">Miniumum, Maximum verteex</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.centroid">
<code class="descname">centroid</code><a class="headerlink" href="#trimesh.points.PointCloud.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean vertex position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>centroid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Mean vertex position</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.colors">
<code class="descname">colors</code><a class="headerlink" href="#trimesh.points.PointCloud.colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Stored per- point color</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>colors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(len(self.vertices), 4) np.uint8</span></dt>
<dd><p class="first last">Per- point RGBA color</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.convex_hull">
<code class="descname">convex_hull</code><a class="headerlink" href="#trimesh.points.PointCloud.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>A convex hull of every point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>convex_hull</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">A watertight mesh of the hull of the points</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.extents">
<code class="descname">extents</code><a class="headerlink" href="#trimesh.points.PointCloud.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the axis aligned bounds</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extents</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Edge length of axis aligned bounding box</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 hash of the current vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Hash of self.vertices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.merge_vertices">
<code class="descname">merge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge vertices closer than tol.merge (default: 1e-8)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.scene">
<code class="descname">scene</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>A scene containing just the PointCloud</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scene</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Scene</span></dt>
<dd><p class="first last">Scene object containing this PointCloud</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.shape">
<code class="descname">shape</code><a class="headerlink" href="#trimesh.points.PointCloud.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of the pointcloud</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2,) int</span></dt>
<dd><p class="first last">Shape of vertex array</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a viewer window displaying the current PointCloud</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.vertices">
<code class="descname">vertices</code><a class="headerlink" href="#trimesh.points.PointCloud.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertices of the PointCloud</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Points in the PointCloud</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.points.k_means">
<code class="descclassname">trimesh.points.</code><code class="descname">k_means</code><span class="sig-paren">(</span><em>points</em>, <em>k</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.k_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Find k centroids that attempt to minimize the k- means problem:
<a class="reference external" href="https://en.wikipedia.org/wiki/Metric_k-center">https://en.wikipedia.org/wiki/Metric_k-center</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points:  (n, d) float</strong></dt>
<dd><p class="first last">Points in a space</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of centroids to compute</p>
</dd>
<dt><strong>**kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Passed directly to scipy.cluster.vq.kmeans</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>centroids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(k, d) float</span></dt>
<dd><p class="first last">Points in some space</p>
</dd>
<dt><strong>labels: (n) int</strong></dt>
<dd><p class="first last">Indexes for which points belong to which centroid</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.major_axis">
<code class="descclassname">trimesh.points.</code><code class="descname">major_axis</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.major_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an approximate vector representing the major axis of points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points: (n, dimension) float, points in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axis: (dimension,) float, vector along approximate major axis</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.plane_fit">
<code class="descclassname">trimesh.points.</code><code class="descname">plane_fit</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.plane_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, find an origin and normal using SVD.</p>
<dl class="docutils">
<dt>points <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd>Points in 3D space</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>C</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Point on the plane</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Normal vector of plane</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.plot_points">
<code class="descclassname">trimesh.points.</code><code class="descname">plot_points</code><span class="sig-paren">(</span><em>points</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.plot_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an (n,3) list of points using matplotlib</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Points in space</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, will not show until plt.show() is called</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.point_plane_distance">
<code class="descclassname">trimesh.points.</code><code class="descname">point_plane_distance</code><span class="sig-paren">(</span><em>points, plane_normal, plane_origin=[0.0, 0.0, 0.0]</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.point_plane_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum perpendicular distance of a point to a plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points:       (n, 3) float, points in space</strong></dt>
<dd></dd>
<dt><strong>plane_normal: (3,) float, normal vector</strong></dt>
<dd></dd>
<dt><strong>plane_origin: (3,) float, plane origin in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distances:     (n,) float, distance from point to plane</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.project_to_plane">
<code class="descclassname">trimesh.points.</code><code class="descname">project_to_plane</code><span class="sig-paren">(</span><em>points, plane_normal=[0, 0, 1], plane_origin=[0, 0, 0], transform=None, return_transform=False, return_planar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.project_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects a set of (n,3) points onto a plane.</p>
<p>points:           (n,3) array of points
plane_normal:     (3) normal vector of plane
plane_origin:     (3) point on plane
transform:        None or (4,4) matrix. If specified, normal/origin are ignored
return_transform: bool, if true returns the (4,4) matrix used to project points</p>
<blockquote>
<div>onto a plane</div></blockquote>
<dl class="docutils">
<dt>return_planar:    bool, if True, returns (n,2) points. If False, returns</dt>
<dd>(n,3), where the Z column consists of zeros</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.radial_sort">
<code class="descclassname">trimesh.points.</code><code class="descname">radial_sort</code><span class="sig-paren">(</span><em>points</em>, <em>origin</em>, <em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.radial_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts a set of points radially (by angle) around an
origin/normal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points: (n,3) float, points in space</strong></dt>
<dd></dd>
<dt><strong>origin: (3,)  float, origin to sort around</strong></dt>
<dd></dd>
<dt><strong>normal: (3,)  float, vector to sort around</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ordered: (n,3) flot, re- ordered points in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.remove_close">
<code class="descclassname">trimesh.points.</code><code class="descname">remove_close</code><span class="sig-paren">(</span><em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.remove_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an (n, m) set of points where n=(2|3) return a list of points
where no point is closer than radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, dimension) float</span></dt>
<dd><p class="first last">Points in space</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum radius between result points</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>culled</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, dimension) float</span></dt>
<dd><p class="first last">Points in space</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) bool</span></dt>
<dd><p class="first last">Which points from the original set were returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.tsp">
<code class="descclassname">trimesh.points.</code><code class="descname">tsp</code><span class="sig-paren">(</span><em>points</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.tsp" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an ordering of points where each is visited and
the next point is the closest in euclidean distance,
and if there are multiple points with equal distance
go to an arbitrary one.</p>
<p>Assumes every point is visitable from every other point,
i.e. the travelling salesman problem on a fully connected
graph. It is not a MINIMUM traversal; rather it is a
“not totally goofy traversal, quickly.” On random points
this traversal is often ~20x shorter than random ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, dimension) float</span></dt>
<dd><p class="first last">ND points in space</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The index of points we should start at</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traversal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) int</span></dt>
<dd><p class="first last">Ordered traversal visiting every point</p>
</dd>
<dt><strong>distances</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n - 1,) float</span></dt>
<dd><p class="first last">The distance between points in the traversal</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.poses">
<span id="trimesh-poses-module"></span><h2>trimesh.poses module<a class="headerlink" href="#module-trimesh.poses" title="Permalink to this headline">¶</a></h2>
<div class="section" id="poses-py">
<h3>poses.py<a class="headerlink" href="#poses-py" title="Permalink to this headline">¶</a></h3>
<p>Find stable orientations of meshes.</p>
<dl class="function">
<dt id="trimesh.poses.compute_stable_poses">
<code class="descclassname">trimesh.poses.</code><code class="descname">compute_stable_poses</code><span class="sig-paren">(</span><em>mesh</em>, <em>center_mass=None</em>, <em>sigma=0.0</em>, <em>n_samples=1</em>, <em>threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.poses.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian with the mean at the center of mass, and a covariance
equal to and identity matrix times sigma, over n_samples.</p>
<p>For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaulates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogenous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.</p>
<p>The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:      Trimesh object, the target mesh</strong></dt>
<dd></dd>
<dt><strong>com:       (3,) float,     the object center of mass (if None, this method</strong></dt>
<dd><p class="first last">assumes uniform density and watertightness and
computes a center of mass explicitly)</p>
</dd>
<dt><strong>sigma:     float,          the covariance for the multivariate gaussian used</strong></dt>
<dd><p class="first last">to sample center of mass locations</p>
</dd>
<dt><strong>n_samples: int,            the number of samples of the center of mass loc</strong></dt>
<dd></dd>
<dt><strong>threshold: float,          the probability value at which to threshold</strong></dt>
<dd><p class="first last">returned stable poses</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transforms: list of (4,4) floats, the homogenous matrices that transform the</strong></dt>
<dd><p class="first last">object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p>
</dd>
<dt><strong>probs:      list of floats,       a probability in (0, 1) for each pose</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.primitives">
<span id="trimesh-primitives-module"></span><h2>trimesh.primitives module<a class="headerlink" href="#module-trimesh.primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="primitives-py">
<h3>primitives.py<a class="headerlink" href="#primitives-py" title="Permalink to this headline">¶</a></h3>
<p>Subclasses of Trimesh objects that are parameterized as primitives.</p>
<p>Useful because you can move boxes and spheres around, and then use
trimesh operations on them at any point.</p>
<dl class="class">
<dt id="trimesh.primitives.Box">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Box</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></dt>
<dd><p class="first last">Summed area of all triangles in the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt>
<dd><p class="first last">The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt>
<dd><p class="first last">How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt>
<dd><p class="first last">An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt>
<dd><p class="first last">An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt>
<dd><p class="first last">A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt>
<dd><p class="first last">The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt>
<dd><p class="first last">A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt>
<dd><p class="first last">The axis aligned bounds of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt>
<dd><p class="first last">The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt>
<dd><p class="first last">The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt>
<dd><p class="first last">Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt>
<dd><p class="first last">Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt>
<dd><p class="first last">Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt>
<dd><p class="first last">Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt>
<dd><p class="first last">Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt>
<dd><p class="first last">The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt>
<dd><p class="first last">How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt>
<dd><p class="first last">Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt>
<dd><p class="first last">The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt>
<dd><p class="first last">Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt>
<dd><p class="first last">Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt>
<dd><p class="first last">Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt>
<dd><p class="first last">Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt>
<dd><p class="first last">The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt>
<dd><p class="first last">The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt>
<dd><p class="first last">The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt>
<dd><p class="first last">An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt>
<dd><p class="first last">Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt>
<dd><p class="first last">Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt>
<dd><p class="first last">Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt>
<dd><p class="first last">The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt>
<dd><p class="first last">For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt>
<dd><p class="first last">Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt>
<dd><p class="first last">Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt>
<dd><p class="first last">Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt>
<dd><p class="first last">Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt>
<dd><p class="first last">Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt>
<dd><p class="first last">Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt>
<dd><p class="first last">Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt>
<dd><p class="first last">An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt>
<dd><p class="first last">Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt>
<dd><p class="first last">Does the current mesh have data defined.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Box.is_oriented" title="trimesh.primitives.Box.is_oriented"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_oriented</span></code></a></dt>
<dd><p class="first last">Returns whether or not the current box is rotated at all.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt>
<dd><p class="first last">Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt>
<dd><p class="first last">Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt>
<dd><p class="first last">Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt>
<dd><p class="first last">Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt>
<dd><p class="first last">Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt>
<dd><p class="first last">Returns the mass properties of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></dt>
<dd><p class="first last">Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt>
<dd><p class="first last">Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt>
<dd><p class="first last">A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt>
<dd><p class="first last">Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd><p class="first last">A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt>
<dd><p class="first last">Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt>
<dd><p class="first last">Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt>
<dd><p class="first last">The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt>
<dd><p class="first last">The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt>
<dd><p class="first last">An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt>
<dd><p class="first last">Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt>
<dd><p class="first last">Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt>
<dd><p class="first last">Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt>
<dd><p class="first last">The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt>
<dd><p class="first last">The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt>
<dd><p class="first last">The vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Box.volume" title="trimesh.primitives.Box.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt>
<dd><p class="first last">Volume of the box Primitive.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</td>
<td>Apply the oriented bounding box transform to the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</td>
<td>Scale the mesh equally on all axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</td>
<td>Apply a transform to the current primitive (sets self.transform)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</td>
<td>Translate the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass,&nbsp;sigma,&nbsp;…])</td>
<td>Computes stable orientations of a mesh and their quasi-static probabilites.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</td>
<td>Given a set of points, determine whether or not they are inside the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[,&nbsp;guess])</td>
<td>Convert the units of the mesh into a specified unit.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine,&nbsp;maxhulls])</td>
<td>Compute an approximate convex decomposition of a mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td>Return a copy of the Primitive object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</td>
<td>A zlib.adler32 checksum for the current mesh data.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[,&nbsp;engine])</td>
<td>Boolean difference between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement,&nbsp;*args)</td>
<td>Evaluate a statement and cache the result before returning.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj,&nbsp;file_type])</td>
<td>Export the current mesh to a file object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</td>
<td>Fill single triangle and single quad holes in the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</td>
<td>Find and fix problems with self.face_normals and self.faces winding direction.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[,&nbsp;engine])</td>
<td>Boolean intersection between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</td>
<td>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</td>
<td>An MD5 of the core geometry information for the mesh, faces and vertices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([distance])</td>
<td>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</td>
<td>Given a set of face ids, find the outline of the faces, and return it as a Path3D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</td>
<td>Do the bare minimum processing to make a mesh useful.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other,&nbsp;**kwargs)</td>
<td>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</td>
<td>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</td>
<td>On the current mesh remove any faces which are duplicates.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</td>
<td>Ensure that every vertex and face consists of finite numbers.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</td>
<td>Remove all vertices in the current mesh which are not referenced by a face.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</td>
<td>Translate the mesh so that all vertex vertices are positive.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[,&nbsp;return_index])</td>
<td>Return random samples distributed normally across the surface of the mesh</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.primitives.Box.sample_grid" title="trimesh.primitives.Box.sample_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_grid</span></code></a>([count,&nbsp;step])</td>
<td>Return a 3D grid which is contained by the box.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.primitives.Box.sample_volume" title="trimesh.primitives.Box.sample_volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_volume</span></code></a>(count)</td>
<td>Return random samples from inside the volume of the box.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</td>
<td>Get a Scene object containing the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal,&nbsp;plane_origin)</td>
<td>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin,&nbsp;…)</td>
<td>Return multiple parallel cross sections of the current mesh in 2D.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</td>
<td>Render the mesh in an opengl window.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</td>
<td>Return a version of the current mesh which will render nicely.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</td>
<td>Returns a list of Trimesh objects, based on face connectivity.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</td>
<td>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence,&nbsp;**kwargs)</td>
<td>Return a subset of the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</td>
<td>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</td>
<td>Return a copy of the Primitive object as a Trimesh object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[,&nbsp;engine])</td>
<td>Boolean union between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</td>
<td>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</td>
<td>In many cases, we will want to remove specific faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[,&nbsp;inverse])</td>
<td>Update vertices with a mask.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch,&nbsp;**kwargs)</td>
<td>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Box.is_oriented">
<code class="descname">is_oriented</code><a class="headerlink" href="#trimesh.primitives.Box.is_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether or not the current box is rotated at all.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.sample_grid">
<code class="descname">sample_grid</code><span class="sig-paren">(</span><em>count=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box.sample_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 3D grid which is contained by the box.
Samples are either ‘step’ distance apart, or there are
‘count’ samples per box side.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>count: int   or (3,) int,   if specified samples are spaced with np.linspace</strong></dt>
<dd></dd>
<dt><strong>step:  float or (3,) float, if specified samples are spaced with np.arange</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grid: (n,3) float, points inside the box</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.sample_volume">
<code class="descname">sample_volume</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box.sample_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples from inside the volume of the box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>count: int, number of samples to return</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples: (count,3) float, points inside the volume</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Box.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Box.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the box Primitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>volume: float, volume of box</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Capsule">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Capsule</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></dt>
<dd><p class="first last">Summed area of all triangles in the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt>
<dd><p class="first last">The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt>
<dd><p class="first last">How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt>
<dd><p class="first last">An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt>
<dd><p class="first last">An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt>
<dd><p class="first last">A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt>
<dd><p class="first last">The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt>
<dd><p class="first last">A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt>
<dd><p class="first last">The axis aligned bounds of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt>
<dd><p class="first last">The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt>
<dd><p class="first last">The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt>
<dd><p class="first last">Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Capsule.direction" title="trimesh.primitives.Capsule.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt>
<dd><p class="first last">The direction of the capsule’s axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt>
<dd><p class="first last">Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt>
<dd><p class="first last">Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt>
<dd><p class="first last">Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt>
<dd><p class="first last">Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt>
<dd><p class="first last">The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt>
<dd><p class="first last">How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt>
<dd><p class="first last">Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt>
<dd><p class="first last">The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt>
<dd><p class="first last">Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt>
<dd><p class="first last">Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt>
<dd><p class="first last">Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt>
<dd><p class="first last">Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt>
<dd><p class="first last">The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt>
<dd><p class="first last">The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt>
<dd><p class="first last">The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt>
<dd><p class="first last">An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt>
<dd><p class="first last">Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt>
<dd><p class="first last">Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt>
<dd><p class="first last">Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt>
<dd><p class="first last">The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt>
<dd><p class="first last">For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt>
<dd><p class="first last">Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt>
<dd><p class="first last">Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt>
<dd><p class="first last">Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt>
<dd><p class="first last">Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt>
<dd><p class="first last">Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt>
<dd><p class="first last">Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt>
<dd><p class="first last">Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt>
<dd><p class="first last">An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt>
<dd><p class="first last">Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt>
<dd><p class="first last">Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt>
<dd><p class="first last">Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt>
<dd><p class="first last">Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt>
<dd><p class="first last">Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt>
<dd><p class="first last">Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt>
<dd><p class="first last">Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt>
<dd><p class="first last">Returns the mass properties of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></dt>
<dd><p class="first last">Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt>
<dd><p class="first last">Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt>
<dd><p class="first last">A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt>
<dd><p class="first last">Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd><p class="first last">A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt>
<dd><p class="first last">Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt>
<dd><p class="first last">Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt>
<dd><p class="first last">The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt>
<dd><p class="first last">The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt>
<dd><p class="first last">An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt>
<dd><p class="first last">Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt>
<dd><p class="first last">Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt>
<dd><p class="first last">Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt>
<dd><p class="first last">The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt>
<dd><p class="first last">The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt>
<dd><p class="first last">The vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></dt>
<dd><p class="first last">Volume of the current mesh calculated using a surface integral.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</td>
<td>Apply the oriented bounding box transform to the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</td>
<td>Scale the mesh equally on all axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</td>
<td>Apply a transform to the current primitive (sets self.transform)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</td>
<td>Translate the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass,&nbsp;sigma,&nbsp;…])</td>
<td>Computes stable orientations of a mesh and their quasi-static probabilites.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</td>
<td>Given a set of points, determine whether or not they are inside the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[,&nbsp;guess])</td>
<td>Convert the units of the mesh into a specified unit.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine,&nbsp;maxhulls])</td>
<td>Compute an approximate convex decomposition of a mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td>Return a copy of the Primitive object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</td>
<td>A zlib.adler32 checksum for the current mesh data.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[,&nbsp;engine])</td>
<td>Boolean difference between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement,&nbsp;*args)</td>
<td>Evaluate a statement and cache the result before returning.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj,&nbsp;file_type])</td>
<td>Export the current mesh to a file object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</td>
<td>Fill single triangle and single quad holes in the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</td>
<td>Find and fix problems with self.face_normals and self.faces winding direction.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[,&nbsp;engine])</td>
<td>Boolean intersection between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</td>
<td>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</td>
<td>An MD5 of the core geometry information for the mesh, faces and vertices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([distance])</td>
<td>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</td>
<td>Given a set of face ids, find the outline of the faces, and return it as a Path3D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</td>
<td>Do the bare minimum processing to make a mesh useful.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other,&nbsp;**kwargs)</td>
<td>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</td>
<td>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</td>
<td>On the current mesh remove any faces which are duplicates.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</td>
<td>Ensure that every vertex and face consists of finite numbers.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</td>
<td>Remove all vertices in the current mesh which are not referenced by a face.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</td>
<td>Translate the mesh so that all vertex vertices are positive.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[,&nbsp;return_index])</td>
<td>Return random samples distributed normally across the surface of the mesh</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</td>
<td>Get a Scene object containing the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal,&nbsp;plane_origin)</td>
<td>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin,&nbsp;…)</td>
<td>Return multiple parallel cross sections of the current mesh in 2D.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</td>
<td>Render the mesh in an opengl window.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</td>
<td>Return a version of the current mesh which will render nicely.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</td>
<td>Returns a list of Trimesh objects, based on face connectivity.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</td>
<td>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence,&nbsp;**kwargs)</td>
<td>Return a subset of the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</td>
<td>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</td>
<td>Return a copy of the Primitive object as a Trimesh object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[,&nbsp;engine])</td>
<td>Boolean union between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</td>
<td>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</td>
<td>In many cases, we will want to remove specific faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[,&nbsp;inverse])</td>
<td>Update vertices with a mask.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch,&nbsp;**kwargs)</td>
<td>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Capsule.direction">
<code class="descname">direction</code><a class="headerlink" href="#trimesh.primitives.Capsule.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The direction of the capsule’s axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axis: (3,) float, vector along the cylinder axis</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Cylinder">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Cylinder</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></dt>
<dd><p class="first last">Summed area of all triangles in the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt>
<dd><p class="first last">The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt>
<dd><p class="first last">How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt>
<dd><p class="first last">An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt>
<dd><p class="first last">An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt>
<dd><p class="first last">A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt>
<dd><p class="first last">The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt>
<dd><p class="first last">A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt>
<dd><p class="first last">The axis aligned bounds of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt>
<dd><p class="first last">The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt>
<dd><p class="first last">The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt>
<dd><p class="first last">Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Cylinder.direction" title="trimesh.primitives.Cylinder.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt>
<dd><p class="first last">The direction of the cylinder’s axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt>
<dd><p class="first last">Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt>
<dd><p class="first last">Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt>
<dd><p class="first last">Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt>
<dd><p class="first last">Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt>
<dd><p class="first last">The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt>
<dd><p class="first last">How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt>
<dd><p class="first last">Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt>
<dd><p class="first last">The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt>
<dd><p class="first last">Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt>
<dd><p class="first last">Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt>
<dd><p class="first last">Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt>
<dd><p class="first last">Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt>
<dd><p class="first last">The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt>
<dd><p class="first last">The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt>
<dd><p class="first last">The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt>
<dd><p class="first last">An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt>
<dd><p class="first last">Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt>
<dd><p class="first last">Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt>
<dd><p class="first last">Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt>
<dd><p class="first last">The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt>
<dd><p class="first last">For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt>
<dd><p class="first last">Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt>
<dd><p class="first last">Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt>
<dd><p class="first last">Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt>
<dd><p class="first last">Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt>
<dd><p class="first last">Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt>
<dd><p class="first last">Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt>
<dd><p class="first last">Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt>
<dd><p class="first last">An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt>
<dd><p class="first last">Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt>
<dd><p class="first last">Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt>
<dd><p class="first last">Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt>
<dd><p class="first last">Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt>
<dd><p class="first last">Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt>
<dd><p class="first last">Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt>
<dd><p class="first last">Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt>
<dd><p class="first last">Returns the mass properties of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Cylinder.moment_inertia" title="trimesh.primitives.Cylinder.moment_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></a></dt>
<dd><p class="first last">The analytic inertia tensor of the cylinder primitive.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt>
<dd><p class="first last">Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt>
<dd><p class="first last">A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt>
<dd><p class="first last">Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd><p class="first last">A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt>
<dd><p class="first last">Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt>
<dd><p class="first last">Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt>
<dd><p class="first last">The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt>
<dd><p class="first last">The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt>
<dd><p class="first last">An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt>
<dd><p class="first last">Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt>
<dd><p class="first last">Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt>
<dd><p class="first last">Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt>
<dd><p class="first last">The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt>
<dd><p class="first last">The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt>
<dd><p class="first last">The vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Cylinder.volume" title="trimesh.primitives.Cylinder.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt>
<dd><p class="first last">The analytic volume of the cylinder primitive.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</td>
<td>Apply the oriented bounding box transform to the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</td>
<td>Scale the mesh equally on all axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</td>
<td>Apply a transform to the current primitive (sets self.transform)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</td>
<td>Translate the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass,&nbsp;sigma,&nbsp;…])</td>
<td>Computes stable orientations of a mesh and their quasi-static probabilites.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</td>
<td>Given a set of points, determine whether or not they are inside the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[,&nbsp;guess])</td>
<td>Convert the units of the mesh into a specified unit.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine,&nbsp;maxhulls])</td>
<td>Compute an approximate convex decomposition of a mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td>Return a copy of the Primitive object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</td>
<td>A zlib.adler32 checksum for the current mesh data.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[,&nbsp;engine])</td>
<td>Boolean difference between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement,&nbsp;*args)</td>
<td>Evaluate a statement and cache the result before returning.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj,&nbsp;file_type])</td>
<td>Export the current mesh to a file object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</td>
<td>Fill single triangle and single quad holes in the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</td>
<td>Find and fix problems with self.face_normals and self.faces winding direction.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[,&nbsp;engine])</td>
<td>Boolean intersection between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</td>
<td>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</td>
<td>An MD5 of the core geometry information for the mesh, faces and vertices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([distance])</td>
<td>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</td>
<td>Given a set of face ids, find the outline of the faces, and return it as a Path3D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</td>
<td>Do the bare minimum processing to make a mesh useful.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other,&nbsp;**kwargs)</td>
<td>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</td>
<td>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</td>
<td>On the current mesh remove any faces which are duplicates.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</td>
<td>Ensure that every vertex and face consists of finite numbers.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</td>
<td>Remove all vertices in the current mesh which are not referenced by a face.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</td>
<td>Translate the mesh so that all vertex vertices are positive.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[,&nbsp;return_index])</td>
<td>Return random samples distributed normally across the surface of the mesh</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</td>
<td>Get a Scene object containing the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal,&nbsp;plane_origin)</td>
<td>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin,&nbsp;…)</td>
<td>Return multiple parallel cross sections of the current mesh in 2D.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</td>
<td>Render the mesh in an opengl window.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</td>
<td>Return a version of the current mesh which will render nicely.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</td>
<td>Returns a list of Trimesh objects, based on face connectivity.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</td>
<td>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence,&nbsp;**kwargs)</td>
<td>Return a subset of the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</td>
<td>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</td>
<td>Return a copy of the Primitive object as a Trimesh object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[,&nbsp;engine])</td>
<td>Boolean union between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</td>
<td>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</td>
<td>In many cases, we will want to remove specific faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[,&nbsp;inverse])</td>
<td>Update vertices with a mask.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch,&nbsp;**kwargs)</td>
<td>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Cylinder.direction">
<code class="descname">direction</code><a class="headerlink" href="#trimesh.primitives.Cylinder.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The direction of the cylinder’s axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axis: (3,) float, vector along the cylinder axis</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Cylinder.moment_inertia">
<code class="descname">moment_inertia</code><a class="headerlink" href="#trimesh.primitives.Cylinder.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic inertia tensor of the cylinder primitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor: (3,3) float, 3D inertia tensor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Cylinder.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Cylinder.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic volume of the cylinder primitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>volume: float, volume of the cylinder</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Extrusion">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Extrusion</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.primitives.Extrusion.area" title="trimesh.primitives.Extrusion.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a></dt>
<dd><p class="first last">The surface area of the primitive extrusion.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt>
<dd><p class="first last">The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt>
<dd><p class="first last">How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt>
<dd><p class="first last">An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt>
<dd><p class="first last">An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt>
<dd><p class="first last">A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt>
<dd><p class="first last">The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt>
<dd><p class="first last">A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt>
<dd><p class="first last">The axis aligned bounds of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt>
<dd><p class="first last">The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt>
<dd><p class="first last">The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt>
<dd><p class="first last">Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Extrusion.direction" title="trimesh.primitives.Extrusion.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt>
<dd><p class="first last">Based on the extrudes transform, what is the vector along</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt>
<dd><p class="first last">Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt>
<dd><p class="first last">Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt>
<dd><p class="first last">Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt>
<dd><p class="first last">Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt>
<dd><p class="first last">The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt>
<dd><p class="first last">How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt>
<dd><p class="first last">Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt>
<dd><p class="first last">The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt>
<dd><p class="first last">Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt>
<dd><p class="first last">Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt>
<dd><p class="first last">Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt>
<dd><p class="first last">Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt>
<dd><p class="first last">The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt>
<dd><p class="first last">The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt>
<dd><p class="first last">The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt>
<dd><p class="first last">An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt>
<dd><p class="first last">Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt>
<dd><p class="first last">Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt>
<dd><p class="first last">Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt>
<dd><p class="first last">The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt>
<dd><p class="first last">For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt>
<dd><p class="first last">Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt>
<dd><p class="first last">Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt>
<dd><p class="first last">Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt>
<dd><p class="first last">Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt>
<dd><p class="first last">Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt>
<dd><p class="first last">Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt>
<dd><p class="first last">Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt>
<dd><p class="first last">An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt>
<dd><p class="first last">Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt>
<dd><p class="first last">Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt>
<dd><p class="first last">Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt>
<dd><p class="first last">Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt>
<dd><p class="first last">Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt>
<dd><p class="first last">Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt>
<dd><p class="first last">Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt>
<dd><p class="first last">Returns the mass properties of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></dt>
<dd><p class="first last">Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt>
<dd><p class="first last">Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt>
<dd><p class="first last">A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt>
<dd><p class="first last">Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd><p class="first last">A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt>
<dd><p class="first last">Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt>
<dd><p class="first last">Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt>
<dd><p class="first last">The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt>
<dd><p class="first last">The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt>
<dd><p class="first last">An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt>
<dd><p class="first last">Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt>
<dd><p class="first last">Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt>
<dd><p class="first last">Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt>
<dd><p class="first last">The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt>
<dd><p class="first last">The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt>
<dd><p class="first last">The vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Extrusion.volume" title="trimesh.primitives.Extrusion.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt>
<dd><p class="first last">The volume of the primitive extrusion.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</td>
<td>Apply the oriented bounding box transform to the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</td>
<td>Scale the mesh equally on all axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</td>
<td>Apply a transform to the current primitive (sets self.transform)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</td>
<td>Translate the current mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.primitives.Extrusion.buffer" title="trimesh.primitives.Extrusion.buffer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">buffer</span></code></a>(distance)</td>
<td>Return a new Extrusion object which is expanded in profile and in height by a specified distance.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass,&nbsp;sigma,&nbsp;…])</td>
<td>Computes stable orientations of a mesh and their quasi-static probabilites.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</td>
<td>Given a set of points, determine whether or not they are inside the mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[,&nbsp;guess])</td>
<td>Convert the units of the mesh into a specified unit.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine,&nbsp;maxhulls])</td>
<td>Compute an approximate convex decomposition of a mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td>Return a copy of the Primitive object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</td>
<td>A zlib.adler32 checksum for the current mesh data.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[,&nbsp;engine])</td>
<td>Boolean difference between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement,&nbsp;*args)</td>
<td>Evaluate a statement and cache the result before returning.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj,&nbsp;file_type])</td>
<td>Export the current mesh to a file object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</td>
<td>Fill single triangle and single quad holes in the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</td>
<td>Find and fix problems with self.face_normals and self.faces winding direction.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[,&nbsp;engine])</td>
<td>Boolean intersection between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</td>
<td>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</td>
<td>An MD5 of the core geometry information for the mesh, faces and vertices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([distance])</td>
<td>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</td>
<td>Given a set of face ids, find the outline of the faces, and return it as a Path3D.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</td>
<td>Do the bare minimum processing to make a mesh useful.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other,&nbsp;**kwargs)</td>
<td>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</td>
<td>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</td>
<td>On the current mesh remove any faces which are duplicates.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</td>
<td>Ensure that every vertex and face consists of finite numbers.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</td>
<td>Remove all vertices in the current mesh which are not referenced by a face.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</td>
<td>Translate the mesh so that all vertex vertices are positive.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[,&nbsp;return_index])</td>
<td>Return random samples distributed normally across the surface of the mesh</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</td>
<td>Get a Scene object containing the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal,&nbsp;plane_origin)</td>
<td>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin,&nbsp;…)</td>
<td>Return multiple parallel cross sections of the current mesh in 2D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</td>
<td>Render the mesh in an opengl window.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.primitives.Extrusion.slide" title="trimesh.primitives.Extrusion.slide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slide</span></code></a>(distance)</td>
<td>Alter the transform of the current extrusion to slide it along its extrude_direction vector</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</td>
<td>Return a version of the current mesh which will render nicely.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</td>
<td>Returns a list of Trimesh objects, based on face connectivity.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</td>
<td>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence,&nbsp;**kwargs)</td>
<td>Return a subset of the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</td>
<td>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</td>
<td>Return a copy of the Primitive object as a Trimesh object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[,&nbsp;engine])</td>
<td>Boolean union between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</td>
<td>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</td>
<td>In many cases, we will want to remove specific faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[,&nbsp;inverse])</td>
<td>Update vertices with a mask.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch,&nbsp;**kwargs)</td>
<td>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Extrusion.area">
<code class="descname">area</code><a class="headerlink" href="#trimesh.primitives.Extrusion.area" title="Permalink to this definition">¶</a></dt>
<dd><p>The surface area of the primitive extrusion.</p>
<p>Calculated from polygon and height to avoid mesh creation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area: float, surface area of 3D extrusion</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.buffer">
<code class="descname">buffer</code><span class="sig-paren">(</span><em>distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Extrusion object which is expanded in profile and
in height by a specified distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>buffered: Extrusion object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Extrusion.direction">
<code class="descname">direction</code><a class="headerlink" href="#trimesh.primitives.Extrusion.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on the extrudes transform, what is the vector along
which the polygon will be extruded</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>direction: (3,) float vector. If self.primitive.transform is an</strong></dt>
<dd><p class="first last">identity matrix this will be [0.0, 0.0, 1.0]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.slide">
<code class="descname">slide</code><span class="sig-paren">(</span><em>distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion.slide" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the transform of the current extrusion to slide it
along its extrude_direction vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance: float, distance along self.extrude_direction to move</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Extrusion.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Extrusion.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The volume of the primitive extrusion.</p>
<p>Calculated from polygon and height to avoid mesh creation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>volume: float, volume of 3D extrusion</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Sphere">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Sphere</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.area" title="trimesh.primitives.Sphere.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a></dt>
<dd><p class="first last">Surface area of the current sphere primitive.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt>
<dd><p class="first last">The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt>
<dd><p class="first last">How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt>
<dd><p class="first last">An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.bounding_box_oriented" title="trimesh.primitives.Sphere.bounding_box_oriented"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></a></dt>
<dd><p class="first last">An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt>
<dd><p class="first last">A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt>
<dd><p class="first last">The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt>
<dd><p class="first last">A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.bounds" title="trimesh.primitives.Sphere.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt>
<dd><p class="first last">The axis aligned bounds of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt>
<dd><p class="first last">The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt>
<dd><p class="first last">The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt>
<dd><p class="first last">Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt>
<dd><p class="first last">The density of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt>
<dd><p class="first last">Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt>
<dd><p class="first last">Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt>
<dd><p class="first last">Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt>
<dd><p class="first last">Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt>
<dd><p class="first last">The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt>
<dd><p class="first last">How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt>
<dd><p class="first last">Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt>
<dd><p class="first last">The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt>
<dd><p class="first last">Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt>
<dd><p class="first last">Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt>
<dd><p class="first last">Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt>
<dd><p class="first last">Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt>
<dd><p class="first last">The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt>
<dd><p class="first last">The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt>
<dd><p class="first last">The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt>
<dd><p class="first last">An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt>
<dd><p class="first last">Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt>
<dd><p class="first last">Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt>
<dd><p class="first last">Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt>
<dd><p class="first last">The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt>
<dd><p class="first last">A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt>
<dd><p class="first last">For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt>
<dd><p class="first last">Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt>
<dd><p class="first last">Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt>
<dd><p class="first last">Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt>
<dd><p class="first last">Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt>
<dd><p class="first last">Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt>
<dd><p class="first last">Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt>
<dd><p class="first last">Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt>
<dd><p class="first last">An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt>
<dd><p class="first last">Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt>
<dd><p class="first last">Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt>
<dd><p class="first last">Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt>
<dd><p class="first last">Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt>
<dd><p class="first last">Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt>
<dd><p class="first last">Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt>
<dd><p class="first last">Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt>
<dd><p class="first last">Returns the mass properties of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.moment_inertia" title="trimesh.primitives.Sphere.moment_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></a></dt>
<dd><p class="first last">The analytic inertia tensor of the sphere primitive.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt>
<dd><p class="first last">Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt>
<dd><p class="first last">A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt>
<dd><p class="first last">Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt>
<dd><p class="first last">A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt>
<dd><p class="first last">Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt>
<dd><p class="first last">If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt>
<dd><p class="first last">Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt>
<dd><p class="first last">The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt>
<dd><p class="first last">The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt>
<dd><p class="first last">An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt>
<dd><p class="first last">Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt>
<dd><p class="first last">Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt>
<dd><p class="first last">Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt>
<dd><p class="first last">The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt>
<dd><p class="first last">The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt>
<dd><p class="first last">The vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.volume" title="trimesh.primitives.Sphere.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt>
<dd><p class="first last">Volume of the current sphere primitive.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</td>
<td>Apply the oriented bounding box transform to the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</td>
<td>Scale the mesh equally on all axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.primitives.Sphere.apply_transform" title="trimesh.primitives.Sphere.apply_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code></a>(matrix)</td>
<td>Apply a transform to the sphere primitive</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</td>
<td>Translate the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass,&nbsp;sigma,&nbsp;…])</td>
<td>Computes stable orientations of a mesh and their quasi-static probabilites.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</td>
<td>Given a set of points, determine whether or not they are inside the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[,&nbsp;guess])</td>
<td>Convert the units of the mesh into a specified unit.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine,&nbsp;maxhulls])</td>
<td>Compute an approximate convex decomposition of a mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td>Return a copy of the Primitive object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</td>
<td>A zlib.adler32 checksum for the current mesh data.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[,&nbsp;engine])</td>
<td>Boolean difference between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement,&nbsp;*args)</td>
<td>Evaluate a statement and cache the result before returning.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj,&nbsp;file_type])</td>
<td>Export the current mesh to a file object.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</td>
<td>Fill single triangle and single quad holes in the current mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</td>
<td>Find and fix problems with self.face_normals and self.faces winding direction.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[,&nbsp;engine])</td>
<td>Boolean intersection between this mesh and n other meshes</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</td>
<td>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</td>
<td>An MD5 of the core geometry information for the mesh, faces and vertices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([distance])</td>
<td>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</td>
<td>Given a set of face ids, find the outline of the faces, and return it as a Path3D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</td>
<td>Do the bare minimum processing to make a mesh useful.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other,&nbsp;**kwargs)</td>
<td>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</td>
<td>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</td>
<td>On the current mesh remove any faces which are duplicates.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</td>
<td>Ensure that every vertex and face consists of finite numbers.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</td>
<td>Remove all vertices in the current mesh which are not referenced by a face.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</td>
<td>Translate the mesh so that all vertex vertices are positive.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[,&nbsp;return_index])</td>
<td>Return random samples distributed normally across the surface of the mesh</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</td>
<td>Get a Scene object containing the current mesh.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal,&nbsp;plane_origin)</td>
<td>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin,&nbsp;…)</td>
<td>Return multiple parallel cross sections of the current mesh in 2D.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</td>
<td>Render the mesh in an opengl window.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</td>
<td>Return a version of the current mesh which will render nicely.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</td>
<td>Returns a list of Trimesh objects, based on face connectivity.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</td>
<td>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence,&nbsp;**kwargs)</td>
<td>Return a subset of the mesh.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</td>
<td>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</td>
<td>Return a copy of the Primitive object as a Trimesh object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[,&nbsp;engine])</td>
<td>Boolean union between this mesh and n other meshes</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</td>
<td>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</td>
<td>In many cases, we will want to remove specific faces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[,&nbsp;inverse])</td>
<td>Update vertices with a mask.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch,&nbsp;**kwargs)</td>
<td>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.primitives.Sphere.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Sphere.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transform to the sphere primitive</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix: (4,4) float, homogenous transformation</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.area">
<code class="descname">area</code><a class="headerlink" href="#trimesh.primitives.Sphere.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface area of the current sphere primitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area: float, surface area of the sphere Primitive</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.bounding_box_oriented">
<code class="descname">bounding_box_oriented</code><a class="headerlink" href="#trimesh.primitives.Sphere.bounding_box_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>An oriented bounding box for the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.primitives.Box</span></dt>
<dd><p class="first last">Box object with transform and extents defined
representing the minimum volume oriented bounding box of the mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.primitives.Sphere.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2, 3) float</span></dt>
<dd><p class="first last">Bounding box with [min, max] coordinates</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.moment_inertia">
<code class="descname">moment_inertia</code><a class="headerlink" href="#trimesh.primitives.Sphere.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic inertia tensor of the sphere primitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tensor: (3,3) float, 3D inertia tensor</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Sphere.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current sphere primitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>volume: float, volume of the sphere Primitive</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.proximity">
<span id="trimesh-proximity-module"></span><h2>trimesh.proximity module<a class="headerlink" href="#module-trimesh.proximity" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proximity-py">
<h3>proximity.py<a class="headerlink" href="#proximity-py" title="Permalink to this headline">¶</a></h3>
<p>Query mesh- point proximity.</p>
<dl class="class">
<dt id="trimesh.proximity.ProximityQuery">
<em class="property">class </em><code class="descclassname">trimesh.proximity.</code><code class="descname">ProximityQuery</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Proximity queries for the current mesh.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.proximity.ProximityQuery.on_surface" title="trimesh.proximity.ProximityQuery.on_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">on_surface</span></code></a>(**kwargs)</td>
<td>Given list of points, for each point find the closest point on any triangle of the mesh.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.proximity.ProximityQuery.signed_distance" title="trimesh.proximity.ProximityQuery.signed_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signed_distance</span></code></a>(points)</td>
<td>Find the signed distance from a mesh to a list of points.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.proximity.ProximityQuery.vertex" title="trimesh.proximity.ProximityQuery.vertex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex</span></code></a>(points)</td>
<td>Given a set of points, return the closest vertex index to each point</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.on_surface">
<code class="descname">on_surface</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.on_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Given list of points, for each point find the closest point
on any triangle of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3) float, points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>closest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3) float, closest point on triangles for each point</span></dt>
<dd></dd>
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)  float, distance</span></dt>
<dd></dd>
<dt><strong>triangle_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)  int, index of closest triangle for each point</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.signed_distance">
<code class="descname">signed_distance</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.signed_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the signed distance from a mesh to a list of points.</p>
<ul class="simple">
<li>Points OUTSIDE the mesh will have NEGATIVE distance</li>
<li>Points within tol.merge of the surface will have POSITIVE distance</li>
<li>Points INSIDE the mesh will have POSITIVE distance</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>signed_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, signed distance from point to mesh</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, return the closest vertex index to each point</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float, distance from source point to vertex</span></dt>
<dd></dd>
<dt><strong>vertex_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) int, index of mesh.vertices which is closest</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.closest_point">
<code class="descclassname">trimesh.proximity.</code><code class="descname">closest_point</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh and a list of points, find the closest point on any triangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd></dd>
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3)   float, points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>closest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3) float, closest point on triangles for each point</span></dt>
<dd></dd>
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)  float, distance</span></dt>
<dd></dd>
<dt><strong>triangle_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)  int, index of triangle containing closest point</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.closest_point_naive">
<code class="descclassname">trimesh.proximity.</code><code class="descname">closest_point_naive</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.closest_point_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh and a list of points, find the closest point on any triangle.</p>
<p>Does this by constructing a very large intermediate array and
comparing every point to every triangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3,3) float, triangles in space</span></dt>
<dd></dd>
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3)   float, points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>closest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3) float, closest point on triangles for each point</span></dt>
<dd></dd>
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)  float, distance</span></dt>
<dd></dd>
<dt><strong>triangle_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,)  int, index of triangle containing closest point</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.longest_ray">
<code class="descclassname">trimesh.proximity.</code><code class="descname">longest_ray</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>directions</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.longest_ray" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the lengths of the longest rays which do not intersect the mesh
cast from a list of points in the provided directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>directions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, directions of rays</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>signed_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float, length of rays</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.max_tangent_sphere">
<code class="descclassname">trimesh.proximity.</code><code class="descname">max_tangent_sphere</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>inwards=True</em>, <em>normals=None</em>, <em>threshold=1e-06</em>, <em>max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.max_tangent_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the center and radius of the sphere which is tangent to
the mesh at the given point and at least one more point with no
non-tangential intersections with the mesh.</p>
<p>Masatomo Inui, Nobuyuki Umezu &amp; Ryohei Shimane (2016)
Shrinking sphere:
A parallel algorithm for computing the thickness of 3D objects,
Computer-Aided Design and Applications, 13:2, 199-207,
DOI: 10.1080/16864360.2015.1084186</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>inwards</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, whether to have the sphere inside or outside the mesh</span></dt>
<dd></dd>
<dt><strong>normals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, normals of the mesh at the given points</span></dt>
<dd><p class="first last">None, compute this automatically.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>centers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, centers of spheres</span></dt>
<dd></dd>
<dt><strong>radii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float, radii of spheres</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.nearby_faces">
<code class="descclassname">trimesh.proximity.</code><code class="descname">nearby_faces</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.nearby_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point find nearby faces relatively quickly.</p>
<p>The closest point on the mesh to the queried point is guaranteed to be
on one of the faces listed.</p>
<p>Does this by finding the nearest vertex on the mesh to each point, and
then returns all the faces that intersect the axis aligned bounding box
centered at the queried point and extending to the nearest vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd></dd>
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float , points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>candidates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(points,) int, sequence of indexes for mesh.faces</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.signed_distance">
<code class="descclassname">trimesh.proximity.</code><code class="descname">signed_distance</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.signed_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the signed distance from a mesh to a list of points.</p>
<ul class="simple">
<li>Points OUTSIDE the mesh will have NEGATIVE distance</li>
<li>Points within tol.merge of the surface will have POSITIVE distance</li>
<li>Points INSIDE the mesh will have POSITIVE distance</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd></dd>
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>signed_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, signed distance from point to mesh</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.thickness">
<code class="descclassname">trimesh.proximity.</code><code class="descname">thickness</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>exterior=False</em>, <em>normals=None</em>, <em>method='max_sphere'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the thickness of the mesh at the given points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, list of points in space</span></dt>
<dd></dd>
<dt><strong>exterior</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, whether to compute the exterior thickness</span></dt>
<dd><p class="first last">(a.k.a. reach)</p>
</dd>
<dt><strong>normals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float, normals of the mesh at the given points</span></dt>
<dd><p class="first last">None, compute this automatically.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, one of ‘max_sphere’ or ‘ray’</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>thickness</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float, thickness</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.registration">
<span id="trimesh-registration-module"></span><h2>trimesh.registration module<a class="headerlink" href="#module-trimesh.registration" title="Permalink to this headline">¶</a></h2>
<div class="section" id="registration-py">
<h3>registration.py<a class="headerlink" href="#registration-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for registering (aligning) point clouds with meshes.</p>
<dl class="function">
<dt id="trimesh.registration.icp">
<code class="descclassname">trimesh.registration.</code><code class="descname">icp</code><span class="sig-paren">(</span><em>a, b, initial=array([[1., 0., 0., 0.],        [0., 1., 0., 0.],        [0., 0., 1., 0.],        [0., 0., 0., 1.]]), threshold=1e-05, max_iterations=20, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.icp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the iterative closest point algorithm to align a point cloud with
another point cloud or mesh. Will only produce reasonable results if the
initial transformation is roughly correct. Initial transformation can be
found by applying Procrustes’ analysis to a suitable set of landmark
points (often picked manually).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">List of points in space.</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m,3) float or Trimesh</span></dt>
<dd><p class="first last">List of points in space or mesh.</p>
</dd>
<dt><strong>initial</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4,4) float</span></dt>
<dd><p class="first last">Initial transformation.</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Stop when change in cost is less than threshold</p>
</dd>
<dt><strong>max_iterations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Args to pass to procrustes</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4,4) float</span></dt>
<dd><p class="first last">The transformation matrix sending a to b</p>
</dd>
<dt><strong>transformed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">The image of a under the transformation</p>
</dd>
<dt><strong>cost</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The cost of the transformation</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.registration.mesh_other">
<code class="descclassname">trimesh.registration.</code><code class="descname">mesh_other</code><span class="sig-paren">(</span><em>mesh</em>, <em>other</em>, <em>samples=500</em>, <em>scale=False</em>, <em>icp_first=10</em>, <em>icp_final=50</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.mesh_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh object</span></dt>
<dd><p class="first last">Mesh to align with other</p>
</dd>
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh or (n, 3) float</span></dt>
<dd><p class="first last">Mesh or points in space</p>
</dd>
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of samples from mesh surface to align</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Allow scaling in transform</p>
</dd>
<dt><strong>icp_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many ICP iterations for the 9 possible
combinations of</p>
</dd>
<dt><strong>icp_final</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many ICP itertations for the closest
candidate from the wider search</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh_to_other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4, 4) float</span></dt>
<dd><p class="first last">Transform to align mesh to the other object</p>
</dd>
<dt><strong>cost</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Average squared distance per point</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.registration.procrustes">
<code class="descclassname">trimesh.registration.</code><code class="descname">procrustes</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>reflection=True</em>, <em>translation=True</em>, <em>scale=True</em>, <em>return_cost=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Procrustes’ analysis subject to constraints. Finds the
transformation T mapping a to b which minimizes the square sum
distances between Ta and b, also called the cost.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">List of points in space</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">List of points in space</p>
</dd>
<dt><strong>reflection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If the transformation is allowed reflections</p>
</dd>
<dt><strong>translation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If the transformation is allowed translations</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If the transformation is allowed scaling</p>
</dd>
<dt><strong>return_cost</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to return the cost and transformed a as well</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4,4) float</span></dt>
<dd><p class="first last">The transformation matrix sending a to b</p>
</dd>
<dt><strong>transformed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">The image of a under the transformation</p>
</dd>
<dt><strong>cost</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The cost of the transformation</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.remesh">
<span id="trimesh-remesh-module"></span><h2>trimesh.remesh module<a class="headerlink" href="#module-trimesh.remesh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="remesh-py">
<h3>remesh.py<a class="headerlink" href="#remesh-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with re- triangulation of existing meshes.</p>
<dl class="function">
<dt id="trimesh.remesh.subdivide">
<code class="descclassname">trimesh.remesh.</code><code class="descname">subdivide</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.remesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh into smaller triangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertices: (n,3) float, vertices</strong></dt>
<dd></dd>
<dt><strong>faces:    (n,3) int,   indexes of vertices which make up triangular faces</strong></dt>
<dd></dd>
<dt><strong>face_index: faces to subdivide.</strong></dt>
<dd><p class="first">if None: all faces of mesh will be subdivided
if (n,) int array of indices: only specified faces will be</p>
<blockquote class="last">
<div><p>subdivided. Note that in this case the mesh will generally
no longer be manifold, as the additional vertex on the midpoint
will not be used by the adjacent faces to the faces specified,
and an additional postprocessing step will be required to
make resulting mesh watertight</p>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_vertices: (n,3) float, vertices</strong></dt>
<dd></dd>
<dt><strong>new_faces:    (n,3) int,   remeshed faces</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.remesh.subdivide_to_size">
<code class="descclassname">trimesh.remesh.</code><code class="descname">subdivide_to_size</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>max_edge</em>, <em>max_iter=10</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.remesh.subdivide_to_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh until every edge is shorter than a specified length.</p>
<p>Will return a triangle soup, not a nicely structured mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertices: (n,3) float, vertices in space</strong></dt>
<dd></dd>
<dt><strong>faces:    (m,3) int,   indices of vertices which make up triangles</strong></dt>
<dd></dd>
<dt><strong>max_edge: float,       maximum length of any edge in the result</strong></dt>
<dd></dd>
<dt><strong>max_iter: int,         the maximum number of times to run subdivisions</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertices: (j,3) float, vertices in space</strong></dt>
<dd></dd>
<dt><strong>faces:    (q,3) int,   indices of vertices</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.rendering">
<span id="trimesh-rendering-module"></span><h2>trimesh.rendering module<a class="headerlink" href="#module-trimesh.rendering" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rendering-py">
<h3>rendering.py<a class="headerlink" href="#rendering-py" title="Permalink to this headline">¶</a></h3>
<p>Functions to convert trimesh objects to pyglet/opengl objects.</p>
<dl class="function">
<dt id="trimesh.rendering.colors_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">colors_to_gl</code><span class="sig-paren">(</span><em>colors</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.colors_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of colors (or None) return a GL- acceptable list of colors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>colors: (count, (3 or 4)) float</strong></dt>
<dd><p class="first last">Input colors as an array</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>colors_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Color type</p>
</dd>
<dt><strong>colors_gl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(count,) list</span></dt>
<dd><p class="first last">Colors to pass to pyglet</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.convert_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">convert_to_vertexlist</code><span class="sig-paren">(</span><em>geometry</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.convert_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to convert various geometry objects to the constructor
args for a pyglet indexed vertex list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh, Path2D, Path3D, (n,2) float, (n,3) float</span></dt>
<dd><p class="first last">Object to render</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Args to be passed to pyglet indexed vertex list
constructor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.matrix_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">matrix_to_gl</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.matrix_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy row- major homogenous transformation matrix
to a flat column- major GLfloat transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(4,4) float</span></dt>
<dd><p class="first last">Row- major homogenous transform</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>glmatrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(16,) pyglet.gl.GLfloat</span></dt>
<dd><p class="first last">Transform in pyglet format</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.mesh_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">mesh_to_vertexlist</code><span class="sig-paren">(</span><em>mesh</em>, <em>group=None</em>, <em>smooth=True</em>, <em>smooth_threshold=60000</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.mesh_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Trimesh object to arguments for an
indexed vertex list constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Mesh to be rendered</p>
</dd>
<dt><strong>group</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Rendering group for the vertex list</p>
</dd>
<dt><strong>smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Should we try to smooth shade the mesh</p>
</dd>
<dt><strong>smooth_threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of faces to smooth shade</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(7,) tuple</span></dt>
<dd><p class="first last">Args for vertex list constructor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.path_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">path_to_vertexlist</code><span class="sig-paren">(</span><em>path</em>, <em>group=None</em>, <em>colors=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.path_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Path3D object to arguments for an
indexed vertex list constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.path.Path3D object</span></dt>
<dd><p class="first last">Mesh to be rendered</p>
</dd>
<dt><strong>group</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Rendering group for the vertex list</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(7,) tuple</span></dt>
<dd><p class="first last">Args for vertex list constructor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.points_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">points_to_vertexlist</code><span class="sig-paren">(</span><em>points</em>, <em>colors=None</em>, <em>group=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.points_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy array of 3D points to args for
a vertex list constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Points to be rendered</p>
</dd>
<dt><strong>colors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) or (n, 4) float</span></dt>
<dd><p class="first last">Colors for each point</p>
</dd>
<dt><strong>group</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Rendering group for the vertex list</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(7,) tuple</span></dt>
<dd><p class="first last">Args for vertex list constructor</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.vector_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">vector_to_gl</code><span class="sig-paren">(</span><em>array</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.vector_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array and an optional set of args into a
flat vector of pyglet.gl.GLfloat</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.repair">
<span id="trimesh-repair-module"></span><h2>trimesh.repair module<a class="headerlink" href="#module-trimesh.repair" title="Permalink to this headline">¶</a></h2>
<div class="section" id="repair-py">
<h3>repair.py<a class="headerlink" href="#repair-py" title="Permalink to this headline">¶</a></h3>
<p>Fill holes and fix winding and normals of meshes.</p>
<dl class="function">
<dt id="trimesh.repair.broken_faces">
<code class="descclassname">trimesh.repair.</code><code class="descname">broken_faces</code><span class="sig-paren">(</span><em>mesh</em>, <em>color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.broken_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of faces in the mesh which break the
watertight status of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
<dt><strong>color: (4,) uint8, will set broken faces to this color</strong></dt>
<dd><p class="first last">None,       will not alter mesh colors</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>broken: (n, ) int, indexes of mesh.faces</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fill_holes">
<code class="descclassname">trimesh.repair.</code><code class="descname">fill_holes</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single- triangle holes on triangular meshes by adding new triangles
to fill the holes. New triangles will have proper winding and normals,
and if face colors exist the color of the last face will be assigned
to the new triangles.</p>
<p>mesh: Trimesh object</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_inversion">
<code class="descclassname">trimesh.repair.</code><code class="descname">fix_inversion</code><span class="sig-paren">(</span><em>mesh</em>, <em>multibody=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a mesh has normals pointing “out.”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh:      Trimesh object</strong></dt>
<dd></dd>
<dt><strong>multibody: bool, if True will try to fix normals on every body</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_normals">
<code class="descclassname">trimesh.repair.</code><code class="descname">fix_normals</code><span class="sig-paren">(</span><em>mesh</em>, <em>multibody=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the winding and direction of a mesh face and
face normals in-place.</p>
<p>Really only meaningful on watertight meshes, but will orient all
faces and winding in a uniform way for non-watertight face
patches as well.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh:      Trimesh object</strong></dt>
<dd></dd>
<dt><strong>multibody: bool, if True try to correct normals direction</strong></dt>
<dd><p class="first last">on every body.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_winding">
<code class="descclassname">trimesh.repair.</code><code class="descname">fix_winding</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_winding" title="Permalink to this definition">¶</a></dt>
<dd><p>Traverse and change mesh faces in-place to make sure winding
is correct, with edges on adjacent faces in
opposite directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.sample">
<span id="trimesh-sample-module"></span><h2>trimesh.sample module<a class="headerlink" href="#module-trimesh.sample" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sample-py">
<h3>sample.py<a class="headerlink" href="#sample-py" title="Permalink to this headline">¶</a></h3>
<p>Randomly sample surface and volume of meshes.</p>
<dl class="function">
<dt id="trimesh.sample.sample_surface">
<code class="descclassname">trimesh.sample.</code><code class="descname">sample_surface</code><span class="sig-paren">(</span><em>mesh</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the surface of a mesh, returning the specified
number of points</p>
<p>For individual triangle sampling uses this method:
<a class="reference external" href="http://mathworld.wolfram.com/TrianglePointPicking.html">http://mathworld.wolfram.com/TrianglePointPicking.html</a></p>
<p>mesh: Trimesh object
count: number of points to return</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples: (count,3) points in space on the surface of mesh</strong></dt>
<dd></dd>
<dt><strong>face_index: (count,) indices of faces for each sampled point</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.sample_surface_even">
<code class="descclassname">trimesh.sample.</code><code class="descname">sample_surface_even</code><span class="sig-paren">(</span><em>mesh</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface_even" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the surface of a mesh, returning samples which are
approximately evenly spaced.</p>
<p>mesh: Trimesh object
count: number of points to return</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples: (count,3) points in space on the surface of mesh</strong></dt>
<dd></dd>
<dt><strong>face_index: (count,) indices of faces for each sampled point</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.sample_surface_sphere">
<code class="descclassname">trimesh.sample.</code><code class="descname">sample_surface_sphere</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Correctly pick random points on the surface of a unit sphere</p>
<p>Uses this method:
<a class="reference external" href="http://mathworld.wolfram.com/SpherePointPicking.html">http://mathworld.wolfram.com/SpherePointPicking.html</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>count: int, number of points to return</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points: (count,3) float, list of random points on a unit sphere</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.volume_mesh">
<code class="descclassname">trimesh.sample.</code><code class="descname">volume_mesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.volume_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Use rejection sampling to produce points randomly distributed
in the volume of a mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh: Trimesh object</strong></dt>
<dd></dd>
<dt><strong>count: int, number of samples desired</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples: (n,3) float, points in the volume of the mesh.</strong></dt>
<dd><p class="first last">where: n &lt;= count</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.volume_rectangular">
<code class="descclassname">trimesh.sample.</code><code class="descname">volume_rectangular</code><span class="sig-paren">(</span><em>extents</em>, <em>count</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.volume_rectangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples inside a rectangular volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>extents:   (3,) float, side lengths of rectangular solid</strong></dt>
<dd></dd>
<dt><strong>count:     int, number of points to return</strong></dt>
<dd></dd>
<dt><strong>transform: (4,4) float, transformation matrix</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples: (count, 3) float, points in volume</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.transformations">
<span id="trimesh-transformations-module"></span><h2>trimesh.transformations module<a class="headerlink" href="#module-trimesh.transformations" title="Permalink to this headline">¶</a></h2>
<p>Homogeneous Transformation Matrices and Quaternions.</p>
<p>A library for calculating 4x4 matrices for translating, rotating, reflecting,
scaling, shearing, projecting, orthogonalizing, and superimposing arrays of
3D homogeneous coordinates as well as for converting between rotation matrices,
Euler angles, and quaternions. Also includes an Arcball control object and
functions to decompose transformation matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body"><a class="reference external" href="http://www.lfd.uci.edu/~gohlke/">Christoph Gohlke</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Organization:</th><td class="field-body">Laboratory for Fluorescence Dynamics, University of California, Irvine</td>
</tr>
<tr class="field-odd field"><th class="field-name">Version:</th><td class="field-body">2017.02.17</td>
</tr>
</tbody>
</table>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org">CPython 2.7 or 3.4</a></li>
<li><a class="reference external" href="http://www.np.org">numpy 1.9</a></li>
<li><a class="reference external" href="http://www.lfd.uci.edu/~gohlke/">Transformations.c 2015.03.19</a>
(recommended for speedup of some functions)</li>
</ul>
</div>
<div class="section" id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h3>
<p>The API is not stable yet and is expected to change between revisions.</p>
<p>This Python code is not optimized for speed. Refer to the transformations.c
module for a faster implementation of some functions.</p>
<p>Documentation in HTML format can be generated with epydoc.</p>
<p>Matrices (M) can be inverted using np.linalg.inv(M), be concatenated using
np.dot(M0, M1), or transform homogeneous coordinate arrays (v) using
np.dot(M, v) for shape (4, *) column vectors, respectively
np.dot(v, M.T) for shape (*, 4) row vectors (“array of points”).</p>
<p>This module follows the “column vectors on the right” and “row major storage”
(C contiguous) conventions. The translation components are in the right column
of the transformation matrix, i.e. M[:3, 3].
The transpose of the transformation matrices may have to be used to interface
with other graphics systems, e.g. with OpenGL’s glMultMatrixd(). See also [16].</p>
<p>Calculations are carried out with np.float64 precision.</p>
<p>Vector, point, quaternion, and matrix function arguments are expected to be
“array like”, i.e. tuple, list, or numpy arrays.</p>
<p>Return types are numpy arrays unless specified otherwise.</p>
<p>Angles are in radians unless specified otherwise.</p>
<p>Quaternions w+ix+jy+kz are represented as [w, x, y, z].</p>
<p>A triple of Euler angles can be applied/interpreted in 24 ways, which can
be specified using a 4 character string or encoded 4-tuple:</p>
<blockquote>
<div><p><em>Axes 4-string</em>: e.g. ‘sxyz’ or ‘ryxy’</p>
<ul class="simple">
<li>first character : rotations are applied to ‘s’tatic or ‘r’otating frame</li>
<li>remaining characters : successive rotation axis ‘x’, ‘y’, or ‘z’</li>
</ul>
<p><em>Axes 4-tuple</em>: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)</p>
<ul class="simple">
<li>inner axis: code of axis (‘x’:0, ‘y’:1, ‘z’:2) of rightmost matrix.</li>
<li>parity : even (0) if inner axis ‘x’ is followed by ‘y’, ‘y’ is followed
by ‘z’, or ‘z’ is followed by ‘x’. Otherwise odd (1).</li>
<li>repetition : first and last axis are same (1) or different (0).</li>
<li>frame : rotations are applied to static (0) or rotating (1) frame.</li>
</ul>
</div></blockquote>
<p>Other Python packages and modules for 3D transformations and quaternions:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><a class="reference external" href="https://pypi.python.org/pypi/transforms3d">Transforms3d</a></dt>
<dd>includes most code of this module.</dd>
</dl>
</li>
<li><a class="reference external" href="http://www.blender.org/api/blender_python_api">Blender.mathutils</a></li>
<li><a class="reference external" href="https://github.com/numpy/numpy-dtypes">numpy-dtypes</a></li>
</ul>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Matrices and transformations. Ronald Goldman.
In “Graphics Gems I”, pp 472-475. Morgan Kaufmann, 1990.</li>
<li>More matrices and transformations: shear and pseudo-perspective.
Ronald Goldman. In “Graphics Gems II”, pp 320-323. Morgan Kaufmann, 1991.</li>
<li>Decomposing a matrix into simple transformations. Spencer Thomas.
In “Graphics Gems II”, pp 320-323. Morgan Kaufmann, 1991.</li>
<li>Recovering the data from the transformation matrix. Ronald Goldman.
In “Graphics Gems II”, pp 324-331. Morgan Kaufmann, 1991.</li>
<li>Euler angle conversion. Ken Shoemake.
In “Graphics Gems IV”, pp 222-229. Morgan Kaufmann, 1994.</li>
<li>Arcball rotation control. Ken Shoemake.
In “Graphics Gems IV”, pp 175-192. Morgan Kaufmann, 1994.</li>
<li>Representing attitude: Euler angles, unit quaternions, and rotation
vectors. James Diebel. 2006.</li>
<li>A discussion of the solution for the best rotation to relate two sets
of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.</li>
<li>Closed-form solution of absolute orientation using unit quaternions.
BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.</li>
<li>Quaternions. Ken Shoemake.
<a class="reference external" href="http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf">http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf</a></li>
<li>From quaternion to matrix and back. JMP van Waveren. 2005.
<a class="reference external" href="http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm">http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm</a></li>
<li>Uniform random rotations. Ken Shoemake.
In “Graphics Gems III”, pp 124-132. Morgan Kaufmann, 1992.</li>
<li>Quaternion in molecular modeling. CFF Karney.
J Mol Graph Mod, 25(5):595-604</li>
<li>New method for extracting the quaternion from a rotation matrix.
Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.</li>
<li>Multiple View Geometry in Computer Vision. Hartley and Zissermann.
Cambridge University Press; 2nd Ed. 2004. Chapter 4, Algorithm 4.7, p 130.</li>
<li>Column Vectors vs. Row Vectors.
<a class="reference external" href="http://steve.hollasch.net/cgindex/math/matrix/column-vec.html">http://steve.hollasch.net/cgindex/math/matrix/column-vec.html</a></li>
</ol>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.123</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.234</span><span class="p">,</span> <span class="mf">2.345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">origin</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">zaxis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rx</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ry</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rz</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">concatenate_matrices</span><span class="p">(</span><span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">,</span> <span class="n">Rz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler</span> <span class="o">=</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">],</span> <span class="n">euler</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Re</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Re</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">al</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ga</span> <span class="o">=</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">Re</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">Re</span><span class="p">,</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">al</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qx</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qy</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qz</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rq</span> <span class="o">=</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Rq</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">scale_matrix</span><span class="p">(</span><span class="mf">1.23</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">translation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span> <span class="o">=</span> <span class="n">shear_matrix</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">random_rotation_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">concatenate_matrices</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span> <span class="o">=</span> <span class="n">decompose_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">compose_matrix</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">random_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">),</span> <span class="n">vector_product</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">v2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="module-trimesh.triangles">
<span id="trimesh-triangles-module"></span><h2>trimesh.triangles module<a class="headerlink" href="#module-trimesh.triangles" title="Permalink to this headline">¶</a></h2>
<div class="section" id="triangles-py">
<h3>triangles.py<a class="headerlink" href="#triangles-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for dealing with triangle soups in (n, 3, 3) float form.</p>
<dl class="function">
<dt id="trimesh.triangles.all_coplanar">
<code class="descclassname">trimesh.triangles.</code><code class="descname">all_coplanar</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.all_coplanar" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a list of triangles are all coplanar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n, 3, 3) float, vertices of triangles</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>all_coplanar, bool, True if all triangles are coplanar</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.any_coplanar">
<code class="descclassname">trimesh.triangles.</code><code class="descname">any_coplanar</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.any_coplanar" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles, if the FIRST triangle is coplanar with ANY
of the following triangles, return True.
Otherwise, return False.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.area">
<code class="descclassname">trimesh.triangles.</code><code class="descname">area</code><span class="sig-paren">(</span><em>triangles=None</em>, <em>crosses=None</em>, <em>sum=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sum area of input triangles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: vertices of triangles (n,3,3)</strong></dt>
<dd></dd>
<dt><strong>sum:       bool, return summed area or individual triangle area</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>area:</strong></dt>
<dd><p class="first last">if sum: float, sum area of triangles
else:   (n,) float, individual area of triangles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.barycentric_to_points">
<code class="descclassname">trimesh.triangles.</code><code class="descname">barycentric_to_points</code><span class="sig-paren">(</span><em>triangles</em>, <em>barycentric</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.barycentric_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of barycentric coordinates on a list of triangles
to cartesian points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles:   (n,3,3) float, list of triangles in space</strong></dt>
<dd></dd>
<dt><strong>barycentric: (n,2) float, barycentric coordinates</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points: (m,3) float, points in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.bounds_tree">
<code class="descclassname">trimesh.triangles.</code><code class="descname">bounds_tree</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.bounds_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles, create an r-tree for broad- phase
collision detection</p>
<p>triangles: (n, 3, 3) list of vertices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tree: Rtree object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.closest_point">
<code class="descclassname">trimesh.triangles.</code><code class="descname">closest_point</code><span class="sig-paren">(</span><em>triangles</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest point on the surface of each triangle for a
list of corresponding points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n,3,3) float, triangles in space</strong></dt>
<dd></dd>
<dt><strong>points:    (n,3)   float, points in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>closest: (n,3) float, point on each triangle closest to each point</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.cross">
<code class="descclassname">trimesh.triangles.</code><code class="descname">cross</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cross product of two edges from input triangles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n, 3, 3) float, vertices of triangles</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>crosses: (n, 3) float, cross product of two edge vectors</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.extents">
<code class="descclassname">trimesh.triangles.</code><code class="descname">extents</code><span class="sig-paren">(</span><em>triangles</em>, <em>areas=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D bounding box size of each triangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n, 3, 3) float, list of triangles</strong></dt>
<dd></dd>
<dt><strong>areas:     (n,) float,      list of triangles area</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>box:       (n,2) float, the size of the 2D oriented bounding box.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.mass_properties">
<code class="descclassname">trimesh.triangles.</code><code class="descname">mass_properties</code><span class="sig-paren">(</span><em>triangles</em>, <em>crosses=None</em>, <em>density=1.0</em>, <em>center_mass=None</em>, <em>skip_inertia=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mass properties of a group of triangles.</p>
<p>Implemented from:
<a class="reference external" href="http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf">http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles:    (n,3,3) float, triangles in space</strong></dt>
<dd></dd>
<dt><strong>crosses:      (n,) float, cross products of triangles</strong></dt>
<dd></dd>
<dt><strong>density:      float, optional override for density</strong></dt>
<dd></dd>
<dt><strong>center_mass:  (3,) float, optional override for center mass</strong></dt>
<dd></dd>
<dt><strong>skip_inertia: bool, if True will not return moments matrix</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info: dict, mass properties</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.nondegenerate">
<code class="descclassname">trimesh.triangles.</code><code class="descname">nondegenerate</code><span class="sig-paren">(</span><em>triangles</em>, <em>areas=None</em>, <em>height=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.nondegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all triangles which have an oriented bounding box
where both of the two sides is larger than a specified height.</p>
<p>Degenerate triangles can be when:
1) Two of the three vertices are colocated
2) All three vertices are unique but colinear</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n, 3, 3) float, list of triangles</strong></dt>
<dd></dd>
<dt><strong>height:    float, minimum edge of a triangle to be kept</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nondegenerate: (n,) bool array of triangles that have area</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.normals">
<code class="descclassname">trimesh.triangles.</code><code class="descname">normals</code><span class="sig-paren">(</span><em>triangles=None</em>, <em>crosses=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normals of input triangles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles:   (n, 3, 3) float, vertex positions</strong></dt>
<dd></dd>
<dt><strong>crosses:     (n, 3) float, cross products of edge vectors</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>normals: (m, 3) float, normal vectors</strong></dt>
<dd></dd>
<dt><strong>valid:   (n,)   bool, valid</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.points_to_barycentric">
<code class="descclassname">trimesh.triangles.</code><code class="descname">points_to_barycentric</code><span class="sig-paren">(</span><em>triangles</em>, <em>points</em>, <em>method='cramer'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.points_to_barycentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the barycentric coordinates of points relative to triangles.</p>
<dl class="docutils">
<dt>The Cramer’s rule solution implements:</dt>
<dd><a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a></dd>
<dt>The cross product solution implements:</dt>
<dd><a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n,3,3) float, triangles in space</strong></dt>
<dd></dd>
<dt><strong>points:    (n,3) float, point in space associated with a triangle</strong></dt>
<dd></dd>
<dt><strong>method:    str, which method to compute the barycentric coordinates with. Options:</strong></dt>
<dd><dl class="first docutils">
<dt>-‘cross’: uses a method using cross products, roughly 2x slower but</dt>
<dd><p class="first last">different numerical robustness properties</p>
</dd>
</dl>
<p class="last">-anything else: uses a cramer’s rule solution</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>barycentric: (n,3) float, barycentric</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.to_kwargs">
<code class="descclassname">trimesh.triangles.</code><code class="descname">to_kwargs</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.to_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of triangles to the kwargs for the Trimesh constructor.</p>
<p>triangles: (n,3,3) float, triangles in space</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kwargs: dict, with keys:</strong></dt>
<dd><p class="first last">‘vertices’ : (n,3) float
‘faces’    : (m,3) int</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>mesh = trimesh.Trimesh(<a href="#id3"><span class="problematic" id="id4">**</span></a>trimesh.triangles.to_kwargs(triangles))</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.windings_aligned">
<code class="descclassname">trimesh.triangles.</code><code class="descname">windings_aligned</code><span class="sig-paren">(</span><em>triangles</em>, <em>normals_compare</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.windings_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles and a list of normals determine if the
two are aligned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangles: (n,3,3) list of vertex locations</strong></dt>
<dd></dd>
<dt><strong>normals_compare: (n,3) list of normals</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>aligned: (n) bool list, are normals aligned with triangles</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.units">
<span id="trimesh-units-module"></span><h2>trimesh.units module<a class="headerlink" href="#module-trimesh.units" title="Permalink to this headline">¶</a></h2>
<div class="section" id="units-py">
<h3>units.py<a class="headerlink" href="#units-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with physical unit systems (i.e. inches, mm)</p>
<p>Very basic conversions, and no requirement for
sympy.physics.units or pint.</p>
<dl class="function">
<dt id="trimesh.units.unit_conversion">
<code class="descclassname">trimesh.units.</code><code class="descname">unit_conversion</code><span class="sig-paren">(</span><em>current</em>, <em>desired</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.units.unit_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the conversion from one set of units to another.</p>
<dl class="docutils">
<dt>current <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Unit system values are in now (eg ‘millimeters’)</dd>
<dt>desired <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Unit system we’d like values in (eg ‘inches’)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>conversion</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number to multiply by to put values into desired units</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.units.units_from_metadata">
<code class="descclassname">trimesh.units.</code><code class="descname">units_from_metadata</code><span class="sig-paren">(</span><em>obj</em>, <em>guess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.units.units_from_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract hints from metadata and if that fails
guess based on the object scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj: object</strong></dt>
<dd><p class="first last">Has attributes ‘metadata’ (dict) and ‘scale’ (float)</p>
</dd>
<dt><strong>guess</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If metadata doesn’t indicate units, guess from scale</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>units: str</strong></dt>
<dd><p class="first last">A guess of what the units might be</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.util">
<span id="trimesh-util-module"></span><h2>trimesh.util module<a class="headerlink" href="#module-trimesh.util" title="Permalink to this headline">¶</a></h2>
<div class="section" id="util-py">
<h3>util.py<a class="headerlink" href="#util-py" title="Permalink to this headline">¶</a></h3>
<p>Standalone functions which require only imports from numpy and the
standard library.</p>
<p>Other libraries may be imported must be wrapped in try/except blocks
or imported inside of a function</p>
<dl class="function">
<dt id="trimesh.util.append_faces">
<code class="descclassname">trimesh.util.</code><code class="descname">append_faces</code><span class="sig-paren">(</span><em>vertices_seq</em>, <em>faces_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.append_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of zero- indexed faces and vertices
combine them into a single array of faces and
a single array of vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertices_seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, ) sequence of (m, d) float</span></dt>
<dd><p class="first last">Multiple arrays of verticesvertex arrays</p>
</dd>
<dt><strong>faces_seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, ) sequence of (p, j) int</span></dt>
<dd><p class="first last">Zero indexed faces for matching vertices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(i, d) float</span></dt>
<dd><p class="first last">Points in space</p>
</dd>
<dt><strong>faces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(j, 3) int</span></dt>
<dd><p class="first last">Reference vertex indices</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.array_to_encoded">
<code class="descclassname">trimesh.util.</code><code class="descname">array_to_encoded</code><span class="sig-paren">(</span><em>array</em>, <em>dtype=None</em>, <em>encoding='base64'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.array_to_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a numpy array to a compact serializable dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Any numpy array</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">Optional dtype to encode array</p>
</dd>
<dt><strong>encoding</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">‘base64’ or ‘binary’</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>encoded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Has keys:
‘dtype’:  str, of dtype
‘shape’:  tuple of shape
‘base64’: str, base64 encoded string</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.array_to_string">
<code class="descclassname">trimesh.util.</code><code class="descname">array_to_string</code><span class="sig-paren">(</span><em>array</em>, <em>col_delim=' '</em>, <em>row_delim='\n'</em>, <em>digits=8</em>, <em>value_format='{}'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.array_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a 1 or 2D array into a string with a specified number
of digits and delimiter. The reason this exists is that the
basic numpy array to string conversions are surprisingly bad.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) or (n, d) float or int</span></dt>
<dd><p class="first last">Data to be converted
If shape is (n,) only column delimiter will be used</p>
</dd>
<dt><strong>col_delim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">What string should separate values in a column</p>
</dd>
<dt><strong>row_delim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">What string should separate values in a row</p>
</dd>
<dt><strong>digits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many digits should floating point numbers include</p>
</dd>
<dt><strong>value_format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Format string for each value or sequence of values
If multiple values per value_format it must divide
into array evenly.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>formatted</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String representation of original array</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.attach_to_log">
<code class="descclassname">trimesh.util.</code><code class="descname">attach_to_log</code><span class="sig-paren">(</span><em>level=10, handler=None, loggers=None, colors=True, blacklist=['TerminalIPythonApp', 'PYREADLINE', 'pyembree', 'shapely.geos', 'shapely.speedups._speedups']</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.attach_to_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a stream handler to all loggers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>level:     logging level</strong></dt>
<dd></dd>
<dt><strong>handler:   log handler object</strong></dt>
<dd></dd>
<dt><strong>loggers:   list of loggers to attach to</strong></dt>
<dd><p class="first last">if None, will try to attach to all available</p>
</dd>
<dt><strong>colors:    bool, if True try to use colorlog formatter</strong></dt>
<dd></dd>
<dt><strong>blacklist: list of str, names of loggers NOT to attach to</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.bounds_tree">
<code class="descclassname">trimesh.util.</code><code class="descname">bounds_tree</code><span class="sig-paren">(</span><em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.bounds_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of axis aligned bounds, create an r-tree for broad- phase
collision detection</p>
<dl class="docutils">
<dt>bounds: (n, dimension*2) list of non- interleaved bounds</dt>
<dd>for a 2D bounds tree:
[(minx, miny, maxx, maxy), …]</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tree: Rtree object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.compress">
<code class="descclassname">trimesh.util.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress data stored in a dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>info: dict, {name in archive: bytes or file-like object}</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>compressed: bytes</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.concatenate">
<code class="descclassname">trimesh.util.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two or more meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a: Trimesh object, or list of such</strong></dt>
<dd></dd>
<dt><strong>b: Trimesh object, or list of such</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: Trimesh object containing concatenated mesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.convert_like">
<code class="descclassname">trimesh.util.</code><code class="descname">convert_like</code><span class="sig-paren">(</span><em>item</em>, <em>like</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.convert_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an item to have the dtype of another item</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>item: item to be converted</strong></dt>
<dd></dd>
<dt><strong>like: object with target dtype. If None, item is returned unmodified</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: item, but in dtype of like</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decimal_to_digits">
<code class="descclassname">trimesh.util.</code><code class="descname">decimal_to_digits</code><span class="sig-paren">(</span><em>decimal</em>, <em>min_digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decimal_to_digits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of digits to the first nonzero decimal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>decimal:    float</strong></dt>
<dd></dd>
<dt><strong>min_digits: int, minimum number of digits to return</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>digits: int, number of digits to the first nonzero decimal</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decode_keys">
<code class="descclassname">trimesh.util.</code><code class="descname">decode_keys</code><span class="sig-paren">(</span><em>store</em>, <em>encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decode_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>If a dictionary has keys that are bytes decode them to a str.</p>
<dl class="docutils">
<dt>store <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Dictionary with data</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Values are untouched but keys that were bytes
are converted to ASCII strings.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decompress">
<code class="descclassname">trimesh.util.</code><code class="descname">decompress</code><span class="sig-paren">(</span><em>file_obj</em>, <em>file_type</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an open file object and a file type, return all components
of the archive as open file objects in a dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>file_obj: open file object</strong></dt>
<dd></dd>
<dt><strong>file_type: str, file extension, ‘zip’, ‘tar.gz’, etc</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>decompressed: dict:</strong></dt>
<dd><p class="first last">{(str, file name) : (file-like object)}</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.diagonal_dot">
<code class="descclassname">trimesh.util.</code><code class="descname">diagonal_dot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.diagonal_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product by row of a and b.</p>
<p>Same as np.diag(np.dot(a, b.T)) but without the monstrous
intermediate matrix.</p>
<p>Also equivalent to:
np.einsum(‘ij,ij-&gt;i’, a, b)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a: (m, d) array</strong></dt>
<dd></dd>
<dt><strong>b: (m, d) array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: (m, d) array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.distance_to_end">
<code class="descclassname">trimesh.util.</code><code class="descname">distance_to_end</code><span class="sig-paren">(</span><em>file_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.distance_to_end" title="Permalink to this definition">¶</a></dt>
<dd><p>For an open file object how far is it to the end</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>file_obj: open file- like object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance: int, bytes to end of file</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.encoded_to_array">
<code class="descclassname">trimesh.util.</code><code class="descname">encoded_to_array</code><span class="sig-paren">(</span><em>encoded</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.encoded_to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a dictionary with base64 encoded strings back into a numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>encoded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><dl class="first last docutils">
<dt>Has keys:</dt>
<dd><p class="first last">dtype: string of dtype
shape: int tuple of shape
base64: base64 encoded string of flat array
binary:  decode result coming from numpy.tostring</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>array: numpy array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.euclidean">
<code class="descclassname">trimesh.util.</code><code class="descname">euclidean</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.euclidean" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean distance between vectors a and b.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">First vector</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd><p class="first last">Second vector</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Euclidean distance between A and B</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.generate_basis">
<code class="descclassname">trimesh.util.</code><code class="descname">generate_basis</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.generate_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an arbitrary basis (coordinate frame)
from the given z-axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>z: (3,) float, a positive z-axis vector.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x: (3,) float, the x axis</strong></dt>
<dd></dd>
<dt><strong>y: (3,) float, the y axis</strong></dt>
<dd></dd>
<dt><strong>z: (3,) float, the z axis</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.grid_arange">
<code class="descclassname">trimesh.util.</code><code class="descname">grid_arange</code><span class="sig-paren">(</span><em>bounds</em>, <em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.grid_arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid from an (2,dimension) bounds with samples step distance apart.</p>
<p>bounds: (2,dimension) list of [[min x, min y, etc], [max x, max y, etc]]
step:   float, or (dimension) floats, separation between points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grid: (n, dimension), points inside the specified bounds</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.grid_linspace">
<code class="descclassname">trimesh.util.</code><code class="descname">grid_linspace</code><span class="sig-paren">(</span><em>bounds</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.grid_linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid spaced inside a bounding box with edges spaced using np.linspace.</p>
<p>bounds: (2,dimension) list of [[min x, min y, etc], [max x, max y, etc]]
count:  int, or (dimension,) int, number of samples per side</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grid: (n, dimension) float, points in the specified bounds</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.hash_file">
<code class="descclassname">trimesh.util.</code><code class="descname">hash_file</code><span class="sig-paren">(</span><em>file_obj</em>, <em>hash_function=&lt;built-in function openssl_md5&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.hash_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hash of an open file- like object.</p>
<p>file_obj: file like object
hash_function: function to use to hash data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hashed: str, hex version of result</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_binary_file">
<code class="descclassname">trimesh.util.</code><code class="descname">is_binary_file</code><span class="sig-paren">(</span><em>file_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_binary_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if file has non-ASCII characters (&gt; 0x7F, or 127)
Should work in both Python 2 and 3</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_file">
<code class="descclassname">trimesh.util.</code><code class="descname">is_file</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is file- like</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Any object type to be checked</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if object is a file</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_instance_named">
<code class="descclassname">trimesh.util.</code><code class="descname">is_instance_named</code><span class="sig-paren">(</span><em>obj</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_instance_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an object, if it is a member of the class ‘name’,
or a subclass of ‘name’, return True.</p>
<dl class="docutils">
<dt>obj <span class="classifier-delimiter">:</span> <span class="classifier">instance</span></dt>
<dd>Some object of some class</dd>
<dt>name: str</dt>
<dd>The name of the class we want to check for</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_instance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the object is a member of the named class</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_none">
<code class="descclassname">trimesh.util.</code><code class="descname">is_none</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if an object is None or not.</p>
<p>Handles the case of np.array(None) as well.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Any object type to be checked</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_none</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if obj is None or numpy None-like</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_sequence">
<code class="descclassname">trimesh.util.</code><code class="descname">is_sequence</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is a sequence or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Any object type to be checked</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_sequence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if object is sequence</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_shape">
<code class="descclassname">trimesh.util.</code><code class="descname">is_shape</code><span class="sig-paren">(</span><em>obj</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the shape of a numpy.ndarray to a target shape,
with any value less than zero being considered a wildcard</p>
<p>Note that if a list- like object is passed that is not a numpy
array, this function will not convert it and will return False.</p>
<dl class="docutils">
<dt>obj <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Array to check the shape on</dd>
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple</span></dt>
<dd>Any negative term will be considered a wildcard
Any tuple term will be evaluated as an OR</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape_ok: bool, True if shape of obj matches query shape</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [1]: a = np.random.random((100, 3))</p>
<p>In [2]: a.shape
Out[2]: (100, 3)</p>
<p>In [3]: trimesh.util.is_shape(a, (-1, 3))
Out[3]: True</p>
<p>In [4]: trimesh.util.is_shape(a, (-1, 3, 5))
Out[4]: False</p>
<p>In [5]: trimesh.util.is_shape(a, (100, -1))
Out[5]: True</p>
<p>In [6]: trimesh.util.is_shape(a, (-1, (3, 4)))
Out[6]: True</p>
<p>In [7]: trimesh.util.is_shape(a, (-1, (4, 5)))
Out[7]: False</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_string">
<code class="descclassname">trimesh.util.</code><code class="descname">is_string</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Any object type to be checked</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if obj is a string</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.jsonify">
<code class="descclassname">trimesh.util.</code><code class="descname">jsonify</code><span class="sig-paren">(</span><em>obj</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.jsonify" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of json.dumps that can handle numpy arrays
by creating a custom encoder for numpy dtypes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">JSON- serializable blob</span></dt>
<dd></dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Passed to json.dumps</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dumped: str, JSON dump of obj</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.make_sequence">
<code class="descclassname">trimesh.util.</code><code class="descname">make_sequence</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.make_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an object, if it is a sequence return, otherwise
add it to a length 1 sequence and return.</p>
<p>Useful for wrapping functions which sometimes return single
objects and other times return lists of objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">An object to be made a sequence</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>as_sequence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) sequence</span></dt>
<dd><p class="first last">Contains input value</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.md5_array">
<code class="descclassname">trimesh.util.</code><code class="descname">md5_array</code><span class="sig-paren">(</span><em>array</em>, <em>digits=5</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.md5_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the MD5 of an array when considering the specified number of digits.</p>
<p>array:  numpy array
digits: int, number of digits to account for in the MD5</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5: str, md5 hash of input</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.md5_object">
<code class="descclassname">trimesh.util.</code><code class="descname">md5_object</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.md5_object" title="Permalink to this definition">¶</a></dt>
<dd><p>If an object is hashable, return the string of the MD5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj: object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>md5: str, MD5 hash</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.multi_dict">
<code class="descclassname">trimesh.util.</code><code class="descname">multi_dict</code><span class="sig-paren">(</span><em>pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.multi_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of key value pairs, create a dictionary.
If a key occurs multiple times, stack the values into an array.</p>
<p>Can be called like the regular dict(pairs) constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pairs: (n,2) array of key, value pairs</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: dict, with all values stored (rather than last with regular dict)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.pairwise">
<code class="descclassname">trimesh.util.</code><code class="descname">pairwise</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>For an iterable, group values into pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>iterable</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, ) list</span></dt>
<dd><p class="first last">A sequence of values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs: (n, 2)</strong></dt>
<dd><p class="first last">Pairs of sequential values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.sigfig_int">
<code class="descclassname">trimesh.util.</code><code class="descname">sigfig_int</code><span class="sig-paren">(</span><em>values</em>, <em>sigfig</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.sigfig_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of floating point values into integers with a specified number
of significant figures and an exponent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>values: (n,) float or int, array of values</strong></dt>
<dd></dd>
<dt><strong>sigfig: (n,) int, number of significant figures to keep</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>as_int:      (n,) int, every value[i] has sigfig[i] digits</strong></dt>
<dd></dd>
<dt><strong>multiplier:  (n, int), exponent, so as_int * 10 ** multiplier is</strong></dt>
<dd><p class="first last">the same order of magnitude as the input</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.sigfig_round">
<code class="descclassname">trimesh.util.</code><code class="descname">sigfig_round</code><span class="sig-paren">(</span><em>values</em>, <em>sigfig=1</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.sigfig_round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round a single value to a specified number of significant figures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>values: float, value to be rounded</strong></dt>
<dd></dd>
<dt><strong>sigfig: int, number of significant figures to reduce to</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rounded: values, but rounded to the specified number of significant figures</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>In [1]: trimesh.util.round_sigfig(-232453.00014045456, 1)
Out[1]: -200000.0</p>
<p>In [2]: trimesh.util.round_sigfig(.00014045456, 1)
Out[2]: 0.0001</p>
<p>In [3]: trimesh.util.round_sigfig(.00014045456, 4)
Out[3]: 0.0001405</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.spherical_to_vector">
<code class="descclassname">trimesh.util.</code><code class="descname">spherical_to_vector</code><span class="sig-paren">(</span><em>spherical</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.spherical_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of (n,2) spherical vectors to (n,3) vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>spherical</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n , 2) float</span></dt>
<dd><p class="first last">Angles, in radians</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Unit vectors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.split_extension">
<code class="descclassname">trimesh.util.</code><code class="descname">split_extension</code><span class="sig-paren">(</span><em>file_name, special=['tar.bz2', 'tar.gz']</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.split_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the file extension of a file name, including support for
special case multipart file extensions (like .tar.gz)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>file_name: str, file name</strong></dt>
<dd></dd>
<dt><strong>special:   list of str, multipart extensions</strong></dt>
<dd><p class="first last">eg: [‘tar.bz2’, ‘tar.gz’]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extension: str, last charecters after a period, or</strong></dt>
<dd><p class="first last">a value from ‘special’</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.stack_lines">
<code class="descclassname">trimesh.util.</code><code class="descname">stack_lines</code><span class="sig-paren">(</span><em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.stack_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack a list of values that represent a polyline into
individual line segments with duplicated consecutive values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>indices: sequence of items</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>stacked: (n,2) set of items</strong></dt>
<dd></dd>
<dt><strong>In [1]: trimesh.util.stack_lines([0,1,2])</strong></dt>
<dd></dd>
<dt><strong>Out[1]:</strong></dt>
<dd></dd>
<dt><strong>array([[0, 1],</strong></dt>
<dd><p class="first last">[1, 2]])</p>
</dd>
<dt><strong>In [2]: trimesh.util.stack_lines([0,1,2,4,5])</strong></dt>
<dd></dd>
<dt><strong>Out[2]:</strong></dt>
<dd></dd>
<dt><strong>array([[0, 1],</strong></dt>
<dd><p class="first last">[1, 2],
[2, 4],
[4, 5]])</p>
</dd>
<dt><strong>In [3]: trimesh.util.stack_lines([[0,0],[1,1],[2,2], [3,3]])</strong></dt>
<dd></dd>
<dt><strong>Out[3]:</strong></dt>
<dd></dd>
<dt><strong>array([[0, 0],</strong></dt>
<dd><p class="first last">[1, 1],
[1, 1],
[2, 2],
[2, 2],
[3, 3]])</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.submesh">
<code class="descclassname">trimesh.util.</code><code class="descname">submesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>faces_sequence</em>, <em>only_watertight=False</em>, <em>append=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of a mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh</span></dt>
<dd><p class="first last">Source mesh to take geometry from</p>
</dd>
<dt><strong>faces_sequence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence (p,) int</span></dt>
<dd><p class="first last">Indexes of mesh.faces</p>
</dd>
<dt><strong>only_watertight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Only return submeshes which are watertight.</p>
</dd>
<dt><strong>append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Return a single mesh which has the faces appended,
if this flag is set, only_watertight is ignored</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>if append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Trimesh object</span></dt>
<dd></dd>
<dt><strong>else        list of Trimesh objects</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.three_dimensionalize">
<code class="descclassname">trimesh.util.</code><code class="descname">three_dimensionalize</code><span class="sig-paren">(</span><em>points</em>, <em>return_2D=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.three_dimensionalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of (n,2) or (n,3) points, return them as (n,3) points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points:    (n, 2) or (n,3) points</strong></dt>
<dd></dd>
<dt><strong>return_2D: boolean flag</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>if return_2D:</strong></dt>
<dd><p class="first last">is_2D: boolean, True if points were (n,2)
points: (n,3) set of points</p>
</dd>
<dt><strong>else:</strong></dt>
<dd><p class="first last">points: (n,3) set of points</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.tolist">
<code class="descclassname">trimesh.util.</code><code class="descname">tolist</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that any arrays or dicts passed containing
numpy arrays are properly converted to lists</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd><p class="first last">Usually a dict with some numpy arrays as values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd><p class="first last">JSON- serializable version of data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.triangle_strips_to_faces">
<code class="descclassname">trimesh.util.</code><code class="descname">triangle_strips_to_faces</code><span class="sig-paren">(</span><em>strips</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.triangle_strips_to_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of triangle strips, convert them to (n,3) faces.</p>
<p>Processes all strips at once using np.concatenate and is significantly
faster than loop- based methods.</p>
<p>From the OpenGL programming guide describing a single triangle
strip [v0, v1, v2, v3, v4]:</p>
<p>Draws a series of triangles (three-sided polygons) using vertices
v0, v1, v2, then v2, v1, v3  (note the order), then v2, v3, v4,
and so on. The ordering is to ensure that the triangles are all
drawn with the same orientation so that the strip can correctly form
part of a surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>strips: (n,) list of (m,) int vertex indices</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>faces: (m,3) int, vertex indices representing triangles</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.type_bases">
<code class="descclassname">trimesh.util.</code><code class="descname">type_bases</code><span class="sig-paren">(</span><em>obj</em>, <em>depth=4</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.type_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bases of the object passed.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.type_named">
<code class="descclassname">trimesh.util.</code><code class="descname">type_named</code><span class="sig-paren">(</span><em>obj</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.type_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to the type() builtin, but looks in class bases
for named instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj: object to look for class of</strong></dt>
<dd></dd>
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, name of class</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>named class, or None</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unique_id">
<code class="descclassname">trimesh.util.</code><code class="descname">unique_id</code><span class="sig-paren">(</span><em>length=12</em>, <em>increment=0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unique_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a decent looking alphanumeric unique identifier.
First 16 bits are time- incrementing, followed by randomness.</p>
<p>This function is used as a nicer looking alternative to:
&gt;&gt;&gt; uuid.uuid4().hex</p>
<p>Follows the advice in:
<a class="reference external" href="https://eager.io/blog/how-long-does-an-id-need-to-be/">https://eager.io/blog/how-long-does-an-id-need-to-be/</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>length:    int, length of resulting identifier</strong></dt>
<dd></dd>
<dt><strong>increment: int, number to add to header uint16</strong></dt>
<dd><p class="first last">useful if calling this function repeatedly
in a tight loop executing faster than time
can increment the header</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>————</strong></dt>
<dd></dd>
<dt><strong>unique: str, unique alphanumeric identifier</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unitize">
<code class="descclassname">trimesh.util.</code><code class="descname">unitize</code><span class="sig-paren">(</span><em>vectors</em>, <em>check_valid=False</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitize a vector or an array or row- vectors.</p>
<dl class="docutils">
<dt>vectors <span class="classifier-delimiter">:</span> <span class="classifier">(n,m) or (j) float</span></dt>
<dd>Vector or vectors to be unitized</dd>
<dt>check_valid <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If set, will return mask of nonzero vectors</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Cutoff for a value to be considered zero.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,m) or (j) float</span></dt>
<dd><p class="first last">Input vectors but unitized</p>
</dd>
<dt><strong>valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) bool or bool</span></dt>
<dd><p class="first last">Mask of nonzero vectors returned if <cite>check_valid</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vector_hemisphere">
<code class="descclassname">trimesh.util.</code><code class="descname">vector_hemisphere</code><span class="sig-paren">(</span><em>vectors</em>, <em>return_sign=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vector_hemisphere" title="Permalink to this definition">¶</a></dt>
<dd><p>For a set of 3D vectors alter the sign so they are all in the
upper hemisphere.</p>
<p>If the vector lies on the plane all vectors with negative Y
will be reversed.</p>
<p>If the vector has a zero Z and Y value vectors with a
negative X value will be reversed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3) float</span></dt>
<dd><p class="first last">Input vectors</p>
</dd>
<dt><strong>return_sign</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Return the sign mask or not</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oriented: (n, 3) float</strong></dt>
<dd><p class="first last">Vectors with same magnitude as source
but possibly reversed to ensure all vectors
are in the same hemisphere.</p>
</dd>
<dt><strong>sign</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vector_to_spherical">
<code class="descclassname">trimesh.util.</code><code class="descname">vector_to_spherical</code><span class="sig-paren">(</span><em>cartesian</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vector_to_spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of cartesian points to (n,2) spherical unit
vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>cartesian</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 3) float</span></dt>
<dd><p class="first last">Points in space</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spherical</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, 2) float</span></dt>
<dd><p class="first last">Angles, in radians</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vstack_empty">
<code class="descclassname">trimesh.util.</code><code class="descname">vstack_empty</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vstack_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>A thin wrapper for numpy.vstack that ignores empty lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tup: tuple or list of arrays with the same number of columns</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>stacked: (n,d) array, with same number of columns as</strong></dt>
<dd><p class="first last">constituent arrays.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.wrap_as_stream">
<code class="descclassname">trimesh.util.</code><code class="descname">wrap_as_stream</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.wrap_as_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap a string or bytes object as a file object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>item: str or bytes</strong></dt>
<dd><p class="first last">Item to be wrapped</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>wrapped: file-like object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.write_encoded">
<code class="descclassname">trimesh.util.</code><code class="descname">write_encoded</code><span class="sig-paren">(</span><em>file_obj</em>, <em>stuff</em>, <em>encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.write_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>If a file is open in binary mode and a string is passed, encode and write
If a file is open in text   mode and bytes are passed, decode and write</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>file_obj: file object,  with ‘write’ and ‘mode’</strong></dt>
<dd></dd>
<dt><strong>stuff:    str or bytes, stuff to be written</strong></dt>
<dd></dd>
<dt><strong>encoding: str,          encoding of text</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.zero_pad">
<code class="descclassname">trimesh.util.</code><code class="descname">zero_pad</code><span class="sig-paren">(</span><em>data</em>, <em>count</em>, <em>right=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.zero_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>data: (n) length 1D array
count: int</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>padded: (count) length 1D array if (n &lt; count), otherwise length (n)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.version">
<span id="trimesh-version-module"></span><h2>trimesh.version module<a class="headerlink" href="#module-trimesh.version" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh.visual">
<span id="trimesh-visual-module"></span><h2>trimesh.visual module<a class="headerlink" href="#module-trimesh.visual" title="Permalink to this headline">¶</a></h2>
<div class="section" id="visual-py">
<h3>visual.py<a class="headerlink" href="#visual-py" title="Permalink to this headline">¶</a></h3>
<p>Hold and deal with visual information about meshes.</p>
<p>There are lots of ways to encode visual information, and the goal of this
architecture is to make it possible to define one, and then transparently
get the others. The two general categories are:</p>
<ol class="arabic simple">
<li>colors, defined for a face, vertex, or material</li>
<li>textures, defined as an image and UV coordinates for each vertex</li>
</ol>
<p>This module only implements diffuse colors at the moment.</p>
</div>
<div class="section" id="rules">
<h3>Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">If nothing is defined sane defaults should be returned</p>
</li>
<li><p class="first">If a user alters or sets a value, that is considered user data
and should be saved and treated as such.</p>
</li>
<li><p class="first">Only one mode of visual is allowed at a time, and setting or altering
a value should transparently change the mode. Color modes are:</p>
<blockquote>
<div><ul class="simple">
<li>vertex colors</li>
<li>face colors</li>
</ul>
</div></blockquote>
</li>
</ol>
<dl class="class">
<dt id="trimesh.visual.ColorVisuals">
<em class="property">class </em><code class="descclassname">trimesh.visual.</code><code class="descname">ColorVisuals</code><span class="sig-paren">(</span><em>mesh=None</em>, <em>face_colors=None</em>, <em>vertex_colors=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.ColorVisuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store color information about a mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.visual.ColorVisuals.defined" title="trimesh.visual.ColorVisuals.defined"><code class="xref py py-obj docutils literal notranslate"><span class="pre">defined</span></code></a></dt>
<dd><p class="first last">Are any colors defined for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.visual.ColorVisuals.face_colors" title="trimesh.visual.ColorVisuals.face_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_colors</span></code></a></dt>
<dd><p class="first last">Colors defined for each face of a mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.visual.ColorVisuals.kind" title="trimesh.visual.ColorVisuals.kind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kind</span></code></a></dt>
<dd><p class="first last">What color mode has been set.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.visual.ColorVisuals.main_color" title="trimesh.visual.ColorVisuals.main_color"><code class="xref py py-obj docutils literal notranslate"><span class="pre">main_color</span></code></a></dt>
<dd><p class="first last">What is the most commonly occurring color.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.visual.ColorVisuals.transparency" title="trimesh.visual.ColorVisuals.transparency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transparency</span></code></a></dt>
<dd><p class="first last">Does the current object contain any transparency.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.visual.ColorVisuals.vertex_colors" title="trimesh.visual.ColorVisuals.vertex_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_colors</span></code></a></dt>
<dd><p class="first last">Return the colors for each vertex of a mesh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.visual.ColorVisuals.concatenate" title="trimesh.visual.ColorVisuals.concatenate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatenate</span></code></a>(other,&nbsp;*args)</td>
<td>Concatenate two or more ColorVisuals objects into a single object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.visual.ColorVisuals.crc" title="trimesh.visual.ColorVisuals.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</td>
<td>A checksum for the current visual object and its parent mesh.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.visual.ColorVisuals.face_subset" title="trimesh.visual.ColorVisuals.face_subset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_subset</span></code></a>(face_index)</td>
<td>Given a mask of face indices, return a sliced version.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.visual.ColorVisuals.update_faces" title="trimesh.visual.ColorVisuals.update_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code></a>(mask)</td>
<td>Apply a mask to remove or duplicate face properties</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.visual.ColorVisuals.update_vertices" title="trimesh.visual.ColorVisuals.update_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code></a>(mask)</td>
<td>Apply a mask to remove or duplicate vertex properties.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.visual.ColorVisuals.concatenate">
<code class="descname">concatenate</code><span class="sig-paren">(</span><em>other</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.ColorVisuals.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two or more ColorVisuals objects into a single object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other: ColorVisuals object</strong></dt>
<dd></dd>
<dt><strong>*args: ColorVisuals objects</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: ColorVisuals object containing information from current</strong></dt>
<dd><p class="first last">object and others in the order it was passed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.visual.ColorVisuals.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.ColorVisuals.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A checksum for the current visual object and its parent mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>crc: int, checksum of data in visual object and its parent mesh</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.visual.ColorVisuals.defined">
<code class="descname">defined</code><a class="headerlink" href="#trimesh.visual.ColorVisuals.defined" title="Permalink to this definition">¶</a></dt>
<dd><p>Are any colors defined for the current mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>defined: bool, are colors defined or not.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.visual.ColorVisuals.face_colors">
<code class="descname">face_colors</code><a class="headerlink" href="#trimesh.visual.ColorVisuals.face_colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Colors defined for each face of a mesh.</p>
<p>If no colors are defined, defaults are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>colors: (len(mesh.faces), 4) uint8, RGBA color for each face</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.visual.ColorVisuals.face_subset">
<code class="descname">face_subset</code><span class="sig-paren">(</span><em>face_index</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.ColorVisuals.face_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mask of face indices, return a sliced version.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>face_index: (n,) int, mask for faces</strong></dt>
<dd><p class="first last">(n,) bool, mask for faces</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>visual: ColorVisuals object containing a subset of faces.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.visual.ColorVisuals.kind">
<code class="descname">kind</code><a class="headerlink" href="#trimesh.visual.ColorVisuals.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>What color mode has been set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mode: ‘face’, ‘vertex’, or None</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.visual.ColorVisuals.main_color">
<code class="descname">main_color</code><a class="headerlink" href="#trimesh.visual.ColorVisuals.main_color" title="Permalink to this definition">¶</a></dt>
<dd><p>What is the most commonly occurring color.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>color: (4,) uint8, most common color</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.visual.ColorVisuals.transparency">
<code class="descname">transparency</code><a class="headerlink" href="#trimesh.visual.ColorVisuals.transparency" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the current object contain any transparency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transparency: bool, does the current visual contain transparency</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.visual.ColorVisuals.update_faces">
<code class="descname">update_faces</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.ColorVisuals.update_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask to remove or duplicate face properties</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.visual.ColorVisuals.update_vertices">
<code class="descname">update_vertices</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.ColorVisuals.update_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask to remove or duplicate vertex properties.</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.visual.ColorVisuals.vertex_colors">
<code class="descname">vertex_colors</code><a class="headerlink" href="#trimesh.visual.ColorVisuals.vertex_colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the colors for each vertex of a mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>colors: (len(mesh.vertices), 4) uint8, color for each vertex</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.visual.colors_to_materials">
<code class="descclassname">trimesh.visual.</code><code class="descname">colors_to_materials</code><span class="sig-paren">(</span><em>colors</em>, <em>count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.colors_to_materials" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of colors into a list of unique materials and material
indexes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>colors: (n,(3,4)) colors</strong></dt>
<dd></dd>
<dt><strong>count:  int, number of entities to apply color to</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>diffuse: (m,4) int, colors</strong></dt>
<dd></dd>
<dt><strong>index:   (count,) int, index of each color</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.concatenate_visuals">
<code class="descclassname">trimesh.visual.</code><code class="descname">concatenate_visuals</code><span class="sig-paren">(</span><em>visuals</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.concatenate_visuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate multiple visual objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>visuals: ColorVisuals object, or list of same</strong></dt>
<dd></dd>
<dt><strong>*args:  ColorVisuals object, or list of same</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>concat: ColorVisuals object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.create_visual">
<code class="descclassname">trimesh.visual.</code><code class="descname">create_visual</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.create_visual" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Visuals object from keyword arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>face_colors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3|4) uint8, colors</span></dt>
<dd></dd>
<dt><strong>vertex_colors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,3|4) uint8, colors</span></dt>
<dd></dd>
<dt><strong>mesh:          Trimesh object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>visuals: ColorVisuals object.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.face_to_vertex_color">
<code class="descclassname">trimesh.visual.</code><code class="descname">face_to_vertex_color</code><span class="sig-paren">(</span><em>mesh</em>, <em>face_colors</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.face_to_vertex_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of face colors into a list of vertex colors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh:        Trimesh object</strong></dt>
<dd></dd>
<dt><strong>face_colors: (n, (3,4)) int, face colors</strong></dt>
<dd></dd>
<dt><strong>dtype:       data type of output</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertex_colors: (m,4) dtype, colors for each vertex</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.hex_to_rgba">
<code class="descclassname">trimesh.visual.</code><code class="descname">hex_to_rgba</code><span class="sig-paren">(</span><em>color</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.hex_to_rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a string hex color to a (4,) RGBA color.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>color: str, hex color</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rgba: (4,) np.uint8, RGBA color</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.random_color">
<code class="descclassname">trimesh.visual.</code><code class="descname">random_color</code><span class="sig-paren">(</span><em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.random_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random RGB color using datatype specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dtype: numpy dtype of result</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>color: (4,) dtype, random color that looks OK</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.to_rgba">
<code class="descclassname">trimesh.visual.</code><code class="descname">to_rgba</code><span class="sig-paren">(</span><em>colors</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.to_rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a single or multiple RGB colors to RGBA colors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>colors: (n,[3|4]) list of RGB or RGBA colors</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>colors: (n,4) list of RGBA colors</strong></dt>
<dd><p class="first last">(4,)  single RGBA color</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.visual.vertex_to_face_color">
<code class="descclassname">trimesh.visual.</code><code class="descname">vertex_to_face_color</code><span class="sig-paren">(</span><em>vertex_colors</em>, <em>faces</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.visual.vertex_to_face_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of vertex colors to face colors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vertex_colors: (n,(3,4)),  colors</strong></dt>
<dd></dd>
<dt><strong>faces:         (m,3) int, face indexes</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>face_colors: (m,4) colors</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.voxel">
<span id="trimesh-voxel-module"></span><h2>trimesh.voxel module<a class="headerlink" href="#module-trimesh.voxel" title="Permalink to this headline">¶</a></h2>
<div class="section" id="voxel-py">
<h3>voxel.py<a class="headerlink" href="#voxel-py" title="Permalink to this headline">¶</a></h3>
<p>Convert meshes to a simple voxel data structure and back again.</p>
<dl class="class">
<dt id="trimesh.voxel.Voxel">
<em class="property">class </em><code class="descclassname">trimesh.voxel.</code><code class="descname">Voxel</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.Voxel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#trimesh.voxel.Voxel.filled_count" title="trimesh.voxel.Voxel.filled_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filled_count</span></code></a></dt>
<dd><p class="first last">Return the number of voxels that are occupied.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.Voxel.marching_cubes" title="trimesh.voxel.Voxel.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">marching_cubes</span></code></a></dt>
<dd><p class="first last">A marching cubes Trimesh representation of the voxels.</p>
</dd>
<dt><strong>pitch</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#trimesh.voxel.Voxel.points" title="trimesh.voxel.Voxel.points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></a></dt>
<dd><p class="first last">The center of each filled cell as a list of points.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.Voxel.shape" title="trimesh.voxel.Voxel.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd><p class="first last">The shape of the matrix for the current voxel object.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.Voxel.volume" title="trimesh.voxel.Voxel.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt>
<dd><p class="first last">What is the volume of the filled cells in the current voxel object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.voxel.Voxel.is_filled" title="trimesh.voxel.Voxel.is_filled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_filled</span></code></a>(point)</td>
<td>Query a point to see if the voxel cell it lies in is filled or not.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.voxel.Voxel.point_to_index" title="trimesh.voxel.Voxel.point_to_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_to_index</span></code></a>(point)</td>
<td>Convert a point to an index in the matrix array.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.voxel.Voxel.filled_count">
<code class="descname">filled_count</code><a class="headerlink" href="#trimesh.voxel.Voxel.filled_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of voxels that are occupied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filled: int, number of voxels that are occupied</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.voxel.Voxel.is_filled">
<code class="descname">is_filled</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.Voxel.is_filled" title="Permalink to this definition">¶</a></dt>
<dd><p>Query a point to see if the voxel cell it lies in is filled or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>point: (3,) float, point in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_filled: bool, is cell occupied or not</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.marching_cubes">
<code class="descname">marching_cubes</code><a class="headerlink" href="#trimesh.voxel.Voxel.marching_cubes" title="Permalink to this definition">¶</a></dt>
<dd><p>A marching cubes Trimesh representation of the voxels.</p>
<p>No effort was made to clean or smooth the result in any way;
it is merely the result of applying the scikit-image
measure.marching_cubes function to self.matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>meshed: Trimesh object representing the current voxel</strong></dt>
<dd><p class="first last">object, as returned by marching cubes algorithm.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.pitch">
<code class="descname">pitch</code><a class="headerlink" href="#trimesh.voxel.Voxel.pitch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.voxel.Voxel.point_to_index">
<code class="descname">point_to_index</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.Voxel.point_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a point to an index in the matrix array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>point: (3,) float, point in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index: (3,) int tuple, index in self.matrix</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.points">
<code class="descname">points</code><a class="headerlink" href="#trimesh.voxel.Voxel.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of each filled cell as a list of points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points: (self.filled, 3) float, list of points</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.shape">
<code class="descname">shape</code><a class="headerlink" href="#trimesh.voxel.Voxel.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the matrix for the current voxel object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape: (3,) int, what is the shape of the 3D matrix</strong></dt>
<dd><p class="first last">for these voxels</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.voxel.Voxel.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>What is the volume of the filled cells in the current voxel object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>volume: float, volume of filled cells</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.voxel.VoxelMesh">
<em class="property">class </em><code class="descclassname">trimesh.voxel.</code><code class="descname">VoxelMesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>pitch</em>, <em>max_iter=10</em>, <em>size_max=None</em>, <em>method='subdivide'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.voxel.Voxel" title="trimesh.voxel.Voxel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.voxel.Voxel</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">filled_count</span></code></dt>
<dd><p class="first last">Return the number of voxels that are occupied.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">marching_cubes</span></code></dt>
<dd><p class="first last">A marching cubes Trimesh representation of the voxels.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.matrix" title="trimesh.voxel.VoxelMesh.matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix</span></code></a></dt>
<dd><p class="first last">A matrix representation of the surface voxels.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.matrix_solid" title="trimesh.voxel.VoxelMesh.matrix_solid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_solid</span></code></a></dt>
<dd><p class="first last">The voxels in a mesh as a 3D matrix.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.matrix_surface" title="trimesh.voxel.VoxelMesh.matrix_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_surface</span></code></a></dt>
<dd><p class="first last">The voxels on the surface of the mesh as a 3D matrix.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.origin" title="trimesh.voxel.VoxelMesh.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></dt>
<dd><p class="first last">The origin of the voxel array.</p>
</dd>
<dt><strong>pitch</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></dt>
<dd><p class="first last">The center of each filled cell as a list of points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt>
<dd><p class="first last">The shape of the matrix for the current voxel object.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.sparse_solid" title="trimesh.voxel.VoxelMesh.sparse_solid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_solid</span></code></a></dt>
<dd><p class="first last">Filled cells inside and on the surface of mesh</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.sparse_surface" title="trimesh.voxel.VoxelMesh.sparse_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_surface</span></code></a></dt>
<dd><p class="first last">Filled cells on the surface of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></dt>
<dd><p class="first last">What is the volume of the filled cells in the current voxel object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#trimesh.voxel.VoxelMesh.as_boxes" title="trimesh.voxel.VoxelMesh.as_boxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_boxes</span></code></a>([solid])</td>
<td>A rough Trimesh representation of the voxels with a box for each filled voxel.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_filled</span></code>(point)</td>
<td>Query a point to see if the voxel cell it lies in is filled or not.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_to_index</span></code>(point)</td>
<td>Convert a point to an index in the matrix array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#trimesh.voxel.VoxelMesh.show" title="trimesh.voxel.VoxelMesh.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>([solid])</td>
<td>Convert the current set of voxels into a trimesh for visualization and show that via its built- in preview method.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.voxel.VoxelMesh.as_boxes">
<code class="descname">as_boxes</code><span class="sig-paren">(</span><em>solid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelMesh.as_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>A rough Trimesh representation of the voxels with a box
for each filled voxel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>solid: bool, if True return boxes for sparse_solid</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh: Trimesh object made up of one box per filled cell.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A matrix representation of the surface voxels.</p>
<p>In the future this is planned to return a filled voxel matrix
if the source mesh is watertight, and a surface voxelization
otherwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix: self.shape np.bool, cell occupancy</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.matrix_solid">
<code class="descname">matrix_solid</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.matrix_solid" title="Permalink to this definition">¶</a></dt>
<dd><p>The voxels in a mesh as a 3D matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix: self.shape np.bool, if a cell is True it is occupied</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.matrix_surface">
<code class="descname">matrix_surface</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.matrix_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>The voxels on the surface of the mesh as a 3D matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix: self.shape np.bool, if a cell is True it is occupied</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.origin">
<code class="descname">origin</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The origin of the voxel array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>origin: (3,) float, point in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="trimesh.voxel.VoxelMesh.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>solid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelMesh.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current set of voxels into a trimesh for visualization
and show that via its built- in preview method.</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.sparse_solid">
<code class="descname">sparse_solid</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.sparse_solid" title="Permalink to this definition">¶</a></dt>
<dd><p>Filled cells inside and on the surface of mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filled: (n, 3) int, filled cells in or on mesh.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.sparse_surface">
<code class="descname">sparse_surface</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.sparse_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Filled cells on the surface of the mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>voxels: (n, 3) int, filled cells on mesh surface</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.boolean_sparse">
<code class="descclassname">trimesh.voxel.</code><code class="descname">boolean_sparse</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>operation=&lt;ufunc 'logical_and'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.boolean_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Find common rows between two arrays very quickly
using 3D boolean sparse matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a: (n, d)  int, coordinates in space</strong></dt>
<dd></dd>
<dt><strong>b: (m, d)  int, coordinates in space</strong></dt>
<dd></dd>
<dt><strong>operation: numpy operation function, ie:</strong></dt>
<dd><p class="first last">np.logical_and
np.logical_or</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords: (q, d) int, coordinates in space</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.fill_voxelization">
<code class="descclassname">trimesh.voxel.</code><code class="descname">fill_voxelization</code><span class="sig-paren">(</span><em>occupied</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.fill_voxelization" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sparse surface voxelization, fill in between columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>occupied: (n, 3) int, location of filled cells</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filled: (m, 3) int, location of filled cells</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.local_voxelize">
<code class="descclassname">trimesh.voxel.</code><code class="descname">local_voxelize</code><span class="sig-paren">(</span><em>mesh</em>, <em>point</em>, <em>pitch</em>, <em>radius</em>, <em>fill=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.local_voxelize" title="Permalink to this definition">¶</a></dt>
<dd><p>Voxelize a mesh in the region of a cube around a point. When fill=True,
uses proximity.contains to fill the resulting voxels so may be meaningless
for non-watertight meshes. Useful to reduce memory cost for small values of
pitch as opposed to global voxelization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mesh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">trimesh.Trimesh</span></dt>
<dd><p class="first last">Source geometry</p>
</dd>
<dt><strong>point</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, ) float</span></dt>
<dd><p class="first last">Point in space to voxelize around</p>
</dd>
<dt><strong>pitch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Side length of a single voxel cube</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of voxel cubes to return in each direction.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">parameters to pass to voxelize_subdivide</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>voxels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(m, m, m) bool</span></dt>
<dd><p class="first last">Array of local voxels where m=2*radius+1</p>
</dd>
<dt><strong>origin_position</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3,) float</span></dt>
<dd><p class="first last">Position of the voxel grid origin in space</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.matrix_to_marching_cubes">
<code class="descclassname">trimesh.voxel.</code><code class="descname">matrix_to_marching_cubes</code><span class="sig-paren">(</span><em>matrix</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.matrix_to_marching_cubes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an (n,m,p) matrix into a mesh, using marching_cubes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix: (n,m,p) bool, voxel matrix</strong></dt>
<dd></dd>
<dt><strong>pitch: float, what pitch was the voxel matrix computed with</strong></dt>
<dd></dd>
<dt><strong>origin: (3,) float, what is the origin of the voxel matrix</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mesh: Trimesh object, generated by meshing voxels using</strong></dt>
<dd><p class="first last">the marching cubes algorithm in skimage</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.matrix_to_points">
<code class="descclassname">trimesh.voxel.</code><code class="descname">matrix_to_points</code><span class="sig-paren">(</span><em>matrix</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.matrix_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an (n,m,p) matrix into a set of points for each voxel center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix: (n,m,p) bool, voxel matrix</strong></dt>
<dd></dd>
<dt><strong>pitch: float, what pitch was the voxel matrix computed with</strong></dt>
<dd></dd>
<dt><strong>origin: (3,) float, what is the origin of the voxel matrix</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points: (q, 3) list of points</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.multibox">
<code class="descclassname">trimesh.voxel.</code><code class="descname">multibox</code><span class="sig-paren">(</span><em>centers</em>, <em>pitch</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.multibox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Trimesh object with a box at every center.</p>
<p>Doesn’t do anything nice or fancy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>centers: (n,3) float, center of boxes that are occupied</strong></dt>
<dd></dd>
<dt><strong>pitch:   float, the edge length of a voxel</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rough: Trimesh object representing inputs</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.sparse_to_matrix">
<code class="descclassname">trimesh.voxel.</code><code class="descname">sparse_to_matrix</code><span class="sig-paren">(</span><em>sparse</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.sparse_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a sparse (n,3) list of integer indexes of filled cells,
turn it into a dense (m,o,p) matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sparse: (n,3) int, index of filled cells</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dense: (m,o,p) bool, matrix of filled cells</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-trimesh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="https-github-com-mikedh-trimesh">
<h3><a class="reference external" href="https://github.com/mikedh/trimesh">https://github.com/mikedh/trimesh</a><a class="headerlink" href="#https-github-com-mikedh-trimesh" title="Permalink to this headline">¶</a></h3>
<p>Trimesh is a pure Python (2.7- 3.3+) library for loading and using triangular meshes with an emphasis on watertight meshes. The goal of the library is to provide a fully featured Trimesh object which allows for easy manipulation and analysis, in the style of the Polygon object in the Shapely library.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="trimesh.interfaces.html" class="btn btn-neutral float-right" title="trimesh.interfaces package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral" title="Module Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Dawson-Haggerty.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.34.8',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>